import {
  require_react_dom
} from "./chunk-5JOAO5RB.js";
import {
  _extends,
  _object_destructuring_empty,
  _object_spread,
  _object_spread_props
} from "./chunk-JB4JATCW.js";
import {
  require_jsx_runtime
} from "./chunk-WMZ4WAD4.js";
import {
  require_react
} from "./chunk-6SWBWRDP.js";
import {
  __toESM
} from "./chunk-4YJ6HKSX.js";

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/Accordion.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useObjectMemo.js
var import_react = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/object.js
var isObjectLike = (object) => {
  return typeof object === "object" && object !== null;
};

// node_modules/@telegram-apps/telegram-ui/dist/helpers/equal.js
var isEqual = (value, other) => {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return false;
  }
  if (isObjectLike(value) && isObjectLike(other)) {
    if (Object.keys(value).length !== Object.keys(other).length) {
      return false;
    }
    for (const prop in value) {
      if (Object.prototype.hasOwnProperty.call(value, prop) && Object.prototype.hasOwnProperty.call(other, prop)) {
        if (!isEqual(value[prop], other[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
};

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useObjectMemo.js
var useObjectMemo = (object) => {
  const cache2 = (0, import_react.useRef)(object);
  if (!isEqual(cache2.current, object)) {
    cache2.current = object;
  }
  return cache2.current;
};

// node_modules/@swc/helpers/esm/_object_without_properties_loose.js
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/@swc/helpers/esm/_object_without_properties.js
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/components/AccordionContent/AccordionContent.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/classNames.js
function classNames(...args) {
  const result = [];
  args.forEach((item) => {
    if (!item) {
      return;
    }
    switch (typeof item) {
      case "string":
        result.push(item);
        break;
      case "object":
        Object.keys(item).forEach((key) => {
          if (item[key]) {
            result.push(key);
          }
        });
        break;
      default:
        result.push(`${item}`);
    }
  });
  return result.join(" ");
}

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/AccordionContext.js
var import_react2 = __toESM(require_react());
var AccordionContext = (0, import_react2.createContext)({
  labelId: "",
  contentId: "",
  expanded: false,
  onChange: () => {
  }
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/components/AccordionContent/helpers/calcMaxHeight.js
var calcMaxHeight = (expanded, bodyElement) => {
  if (!expanded) {
    return "0px";
  }
  if (bodyElement === null) {
    return "inherit";
  }
  return `${bodyElement.scrollHeight}px`;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/components/AccordionContent/AccordionContent.js
var AccordionContent = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  const bodyRef = (0, import_react3.useRef)(null);
  const { expanded, labelId, contentId } = (0, import_react3.useContext)(AccordionContext);
  return (0, import_jsx_runtime.jsx)("div", _object_spread_props(_object_spread({
    id: contentId,
    role: "region",
    "aria-labelledby": labelId,
    "aria-hidden": !expanded,
    className: classNames("tgui-f23c0e195677169c", className)
  }, restProps), {
    children: (0, import_jsx_runtime.jsx)("div", {
      ref: bodyRef,
      className: "tgui-947b927060015de8",
      style: {
        maxHeight: calcMaxHeight(expanded, bodyRef.current)
      },
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/components/AccordionSummary/AccordionSummary.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var import_react14 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/function.js
var callMultiple = (...fns) => (...args) => fns.filter((f) => typeof f === "function").forEach((f) => f(...args));

// node_modules/@telegram-apps/telegram-ui/dist/icons/24/chevron_down.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var Icon24ChevronDown = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime2.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime2.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.3 7.54a1 1 0 0 1 1.4 0l6.8 6.8 6.8-6.8a1 1 0 1 1 1.4 1.42l-7.5 7.5a1 1 0 0 1-1.4 0l-7.5-7.5a1 1 0 0 1 0-1.42Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/Cell.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var import_react13 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/react/node.js
var hasReactNode = (value) => {
  return value !== void 0 && value !== false && value !== null && value !== "";
};
function isPrimitiveReactNode(node) {
  return typeof node === "string" || typeof node === "number";
}

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useAppRootContext.js
var import_react5 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/AppRootContext.js
var import_react4 = __toESM(require_react());
var AppRootContext = (0, import_react4.createContext)({
  isRendered: false
});

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useAppRootContext.js
var useAppRootContext = () => {
  const appRootContext = (0, import_react5.useContext)(AppRootContext);
  if (!appRootContext.isRendered) {
    throw new Error("[TGUI] Wrap your app with <AppRoot> component");
  }
  return appRootContext;
};

// node_modules/@telegram-apps/telegram-ui/dist/hooks/usePlatform.js
var usePlatform = () => {
  const context = useAppRootContext();
  return context.platform || "base";
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Tappable/Tappable.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Tappable/components/Ripple/hooks/useRipple.js
var import_react8 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useTimeout.js
var import_react7 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useEnhancedEffect.js
var import_react6 = __toESM(require_react());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@telegram-apps/telegram-ui/dist/helpers/dom.js
var canUseDOM = (() => !!(typeof window !== "undefined" && window.document && window.document.createElement))();
var getHTMLElementByChildren = (children, index2) => {
  const foundEl = children[index2];
  return isHTMLElement(foundEl) ? foundEl : null;
};
var getHTMLElementSiblingByDirection = (el, direction) => {
  let siblingEl = null;
  switch (direction) {
    case "left":
      siblingEl = el.previousElementSibling;
      break;
    case "right":
      siblingEl = el.nextElementSibling;
      break;
    default:
      return null;
  }
  return isHTMLElement(siblingEl) ? siblingEl : null;
};

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useEnhancedEffect.js
var useEnhancedEffect = canUseDOM ? import_react6.useLayoutEffect : import_react6.useEffect;

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useTimeout.js
var useTimeout = (callbackFunction, duration) => {
  const options = (0, import_react7.useRef)({
    callbackFunction,
    duration
  });
  useEnhancedEffect(() => {
    options.current.callbackFunction = callbackFunction;
    options.current.duration = duration;
  }, [
    callbackFunction,
    duration
  ]);
  const timeout = (0, import_react7.useRef)();
  const clear = (0, import_react7.useCallback)(() => clearTimeout(timeout === null || timeout === void 0 ? void 0 : timeout.current), []);
  const set2 = (0, import_react7.useCallback)(() => {
    clear();
    timeout.current = setTimeout(options.current.callbackFunction, options.current.duration);
  }, [
    clear
  ]);
  return {
    set: set2,
    clear
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Tappable/components/Ripple/hooks/useRipple.js
var RIPPLE_DELAY = 70;
var WAVE_LIVE = 225;
var useRipple = () => {
  const [clicks, setClicks] = (0, import_react8.useState)([]);
  const pointerDelayTimers = (0, import_react8.useMemo)(() => /* @__PURE__ */ new Map(), []);
  const clearClicks = useTimeout(() => setClicks([]), WAVE_LIVE);
  function addClick(x, y, pointerId) {
    const dateNow = Date.now();
    const filteredClicks = clicks.filter((click) => click.date + WAVE_LIVE > dateNow);
    setClicks([
      ...filteredClicks,
      {
        x,
        y,
        date: dateNow,
        pointerId
      }
    ]);
    clearClicks.set();
    pointerDelayTimers.delete(pointerId);
  }
  const onPointerDown = (e) => {
    const { top, left } = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - (left !== null && left !== void 0 ? left : 0);
    const y = e.clientY - (top !== null && top !== void 0 ? top : 0);
    pointerDelayTimers.set(e.pointerId, setTimeout(() => addClick(x, y, e.pointerId), RIPPLE_DELAY));
  };
  const onPointerCancel = (e) => {
    const timer = pointerDelayTimers.get(e.pointerId);
    clearTimeout(timer);
    pointerDelayTimers.delete(e.pointerId);
  };
  return {
    clicks,
    onPointerDown,
    onPointerCancel
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Tappable/components/Ripple/Ripple.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var Ripple = ({ clicks }) => (0, import_jsx_runtime3.jsx)("span", {
  "aria-hidden": true,
  className: "tgui-8071f6e38c77bc0b",
  children: clicks.map((wave) => (0, import_jsx_runtime3.jsx)("span", {
    className: "tgui-e156954daf886976",
    style: {
      top: wave.y,
      left: wave.x
    }
  }, wave.date))
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Tappable/Tappable.js
var Tappable = (0, import_react9.forwardRef)((_param, ref) => {
  var { Component = "div", children, className, interactiveAnimation = "background", readOnly } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "children",
    "className",
    "interactiveAnimation",
    "readOnly"
  ]);
  const platform2 = usePlatform();
  const { clicks, onPointerCancel, onPointerDown } = useRipple();
  const hasRippleEffect = platform2 === "base" && interactiveAnimation === "background" && !readOnly;
  return (0, import_jsx_runtime4.jsxs)(Component, _object_spread_props(_object_spread({
    ref,
    className: classNames("tgui-b5d680db78c4cc2e", platform2 === "ios" && "tgui-34eb6f8b96874d40", interactiveAnimation === "opacity" && "tgui-7c5d6c1f6bbe3eaf", className),
    onPointerCancel,
    onPointerDown,
    readOnly
  }, restProps), {
    children: [
      hasRippleEffect && (0, import_jsx_runtime4.jsx)(Ripple, {
        clicks
      }),
      children
    ]
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Subheadline/Subheadline.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Typography.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());
var stylesWeight = {
  "1": "tgui-5c92f90c2701fa17",
  "2": "tgui-809f1f8a3f64154d",
  "3": "tgui-5b8bdfbd2af10f59"
};
var Typography = (0, import_react10.forwardRef)((_param, ref) => {
  var { weight = "3", Component = "span", plain = true, caps, className } = _param, restProps = _object_without_properties(_param, [
    "weight",
    "Component",
    "plain",
    "caps",
    "className"
  ]);
  return (0, import_jsx_runtime5.jsx)(Component, _object_spread({
    ref,
    className: classNames("tgui-c3e2e598bd70eee6", plain && "tgui-080a44e6ac3f4d27", weight && stylesWeight[weight], caps && "tgui-c602097b30e4ede9", className)
  }, restProps));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Subheadline/Subheadline.js
var subheadlineLevelStyles = {
  "1": "tgui-30064fce0d501f17",
  "2": "tgui-8f63cd31b2513281"
};
var Subheadline = (0, import_react11.forwardRef)((_param, ref) => {
  var { level = "1", className, Component } = _param, restProps = _object_without_properties(_param, [
    "level",
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime6.jsx)(Typography, _object_spread_props(_object_spread({}, restProps), {
    ref,
    className: classNames("tgui-266b6ffdbad2b90e", subheadlineLevelStyles[level], className),
    Component: Component || "h6"
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/hooks/useTypographyCellComponents.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Caption/Caption.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var captionLevelStyles = {
  "1": "tgui-2916d621b0ea5857",
  "2": "tgui-937d123c23df98b3"
};
var Caption = (_param) => {
  var { level = "1", className, Component } = _param, restProps = _object_without_properties(_param, [
    "level",
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime7.jsx)(Typography, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("tgui-f37a43dcc29ade55", captionLevelStyles[level], className),
    Component: Component || "span"
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Text/Text.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());
var Text = (0, import_react12.forwardRef)((_param, ref) => {
  var { weight, className, Component } = _param, restProps = _object_without_properties(_param, [
    "weight",
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime8.jsx)(Typography, _object_spread_props(_object_spread({
    ref
  }, restProps), {
    weight,
    className: classNames("tgui-65c206f0fd891b6b", className),
    Component: Component || "span"
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/hooks/useTypographyCellComponents.js
var useTypographyCellComponents = () => {
  const platform2 = usePlatform();
  const isIOS2 = platform2 === "ios";
  const Title3 = (props) => {
    if (isIOS2) {
      return (0, import_jsx_runtime9.jsx)(Text, _object_spread({}, props));
    }
    return (0, import_jsx_runtime9.jsx)(Subheadline, _object_spread({
      level: "1"
    }, props));
  };
  const Description2 = (props) => {
    if (isIOS2) {
      return (0, import_jsx_runtime9.jsx)(Caption, _object_spread({}, props));
    }
    return (0, import_jsx_runtime9.jsx)(Subheadline, _object_spread({
      level: "2"
    }, props));
  };
  return {
    Title: Title3,
    Description: Description2
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/Cell.js
var Cell = (0, import_react13.forwardRef)((_param, ref) => {
  var { children, titleBadge, hint, subhead, subtitle, description, className, before, after, Component, hovered, multiline } = _param, restProps = _object_without_properties(_param, [
    "children",
    "titleBadge",
    "hint",
    "subhead",
    "subtitle",
    "description",
    "className",
    "before",
    "after",
    "Component",
    "hovered",
    "multiline"
  ]);
  const platform2 = usePlatform();
  const { Title: Title3, Description: Description2 } = useTypographyCellComponents();
  const hasTitle = hasReactNode(children) || hasReactNode(hint) || hasReactNode(titleBadge);
  return (0, import_jsx_runtime10.jsxs)(Tappable, _object_spread_props(_object_spread({
    ref,
    Component: Component || "div",
    className: classNames("tgui-b8dfba0b5c3d054c", platform2 === "ios" && "tgui-7b5bccbb645b495f", hovered && "tgui-7edaaf0c57797623", multiline && "tgui-6c49dadccf648a5b", className)
  }, restProps), {
    children: [
      hasReactNode(before) && (0, import_jsx_runtime10.jsx)("div", {
        className: "tgui-aaa795d78c356ac1",
        children: before
      }),
      (0, import_jsx_runtime10.jsxs)("div", {
        className: "tgui-8735a62be5a8b8a7",
        children: [
          hasReactNode(subhead) && (0, import_jsx_runtime10.jsx)(Subheadline, {
            className: "tgui-46dd90b57ffed25f",
            level: "2",
            weight: "3",
            children: subhead
          }),
          hasTitle && (0, import_jsx_runtime10.jsxs)(Title3, {
            className: "tgui-a894f59f4c5ad72f",
            children: [
              hasReactNode(children) && (0, import_jsx_runtime10.jsx)("span", {
                className: "tgui-1c6d7865a76a19bc",
                children
              }),
              hasReactNode(hint) && (0, import_jsx_runtime10.jsx)("span", {
                className: "tgui-bb909928b48f948b",
                children: hint
              }),
              hasReactNode(titleBadge) && titleBadge
            ]
          }),
          hasReactNode(subtitle) && (0, import_jsx_runtime10.jsx)(Subheadline, {
            className: "tgui-d528ef65a8b76273",
            level: "2",
            weight: "3",
            children: subtitle
          }),
          hasReactNode(description) && (0, import_jsx_runtime10.jsx)(Description2, {
            className: "tgui-fc059ed3ac5799a6",
            children: description
          })
        ]
      }),
      hasReactNode(after) && (0, import_jsx_runtime10.jsx)("div", {
        className: "tgui-56b2e897ed7ccb22",
        children: after
      })
    ]
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/components/AccordionSummary/AccordionSummary.js
var AccordionSummary = (_param) => {
  var { after, before, onClick, children } = _param, restProps = _object_without_properties(_param, [
    "after",
    "before",
    "onClick",
    "children"
  ]);
  const { expanded, labelId, contentId, onChange } = (0, import_react14.useContext)(AccordionContext);
  const toggle = () => onChange(!expanded);
  return (0, import_jsx_runtime11.jsx)(Cell, _object_spread_props(_object_spread({
    id: labelId,
    "aria-expanded": expanded,
    "aria-controls": contentId,
    onClick: callMultiple(toggle, onClick),
    after: after || (0, import_jsx_runtime11.jsx)(Icon24ChevronDown, {
      className: classNames("tgui-60e7968097edfa6f", expanded && "tgui-c900ecbd6d8d6d5e")
    })
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/hooks/useAccordionId.js
var import_react15 = __toESM(require_react());
var useAccordionId = (id) => {
  const randomId = (0, import_react15.useId)();
  const labelId = id !== null && id !== void 0 ? id : `Accordion${randomId}`;
  const contentId = `AccordionContent${id !== null && id !== void 0 ? id : randomId}`;
  return {
    labelId,
    contentId
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Accordion/Accordion.js
var Accordion = ({ id, expanded, onChange, children }) => {
  const { labelId, contentId } = useAccordionId(id);
  const context = useObjectMemo({
    labelId,
    contentId,
    expanded,
    onChange
  });
  return (0, import_jsx_runtime12.jsx)(AccordionContext.Provider, {
    value: context,
    children
  });
};
Accordion.Summary = AccordionSummary;
Accordion.Content = AccordionContent;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Avatar/Avatar.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Image/Image.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_react16 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Image/helpers/getBorderRadius.js
var getBorderRadius = (size4) => {
  if (size4 < 40) {
    return 4;
  }
  if (size4 < 96) {
    return 8;
  }
  return 12;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Image/components/ImageBadge/ImageBadge.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Badge/Badge.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var typeStyles = {
  number: "tgui-562f7459d74103ea",
  dot: "tgui-4f69ed647e40e245"
};
var modeStyles = {
  primary: "tgui-6e63faaa2b33f4ae",
  critical: "tgui-4b52474c713ffa7c",
  secondary: "tgui-0278f262d68294f0",
  gray: "tgui-0883e451f3707277",
  white: "tgui-6b3dbcedd9052940"
};
var Badge = (_param) => {
  var { type, mode = "primary", large, className, children } = _param, restProps = _object_without_properties(_param, [
    "type",
    "mode",
    "large",
    "className",
    "children"
  ]);
  const isNumber = type === "number";
  return (0, import_jsx_runtime13.jsx)("span", _object_spread_props(_object_spread({
    className: classNames("tgui-c8f4bcd1606fb026", typeStyles[type], modeStyles[mode], isNumber && large && "tgui-c1a5e9170826a773", className)
  }, restProps), {
    children: hasReactNode(children) && isNumber && (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, {
      children: [
        large && (0, import_jsx_runtime13.jsx)(Subheadline, {
          Component: "span",
          level: "2",
          weight: "2",
          children
        }),
        !large && (0, import_jsx_runtime13.jsx)(Caption, {
          weight: "2",
          children
        })
      ]
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Image/components/ImageBadge/ImageBadge.js
var ImageBadge = (_param) => {
  var { type, className } = _param, restProps = _object_without_properties(_param, [
    "type",
    "className"
  ]);
  if (type !== "number") {
    console.error('[ImageBadge]: Component supports only type="number"');
    return null;
  }
  return (0, import_jsx_runtime14.jsx)(Badge, _object_spread({
    type: "number",
    className: classNames("tgui-e3bcc434a6ee9317", className)
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Image/Image.js
var Image = (_param) => {
  var { size: size4 = 40, className, alt, crossOrigin, decoding, loading, referrerPolicy, sizes, src, srcSet, useMap, style, fallbackIcon, children, onLoad, onError } = _param, restProps = _object_without_properties(_param, [
    "size",
    "className",
    "alt",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "src",
    "srcSet",
    "useMap",
    "style",
    "fallbackIcon",
    "children",
    "onLoad",
    "onError"
  ]);
  const [loaded, setLoaded] = (0, import_react16.useState)(false);
  const [failed, setFailed] = (0, import_react16.useState)(false);
  const hasSrc = src || (srcSet === null || srcSet === void 0 ? void 0 : srcSet.length) !== 0;
  const needShowFallbackIcon = (failed || !hasSrc) && (0, import_react16.isValidElement)(fallbackIcon);
  const handleImageLoad = (event) => {
    if (loaded) {
      return;
    }
    setLoaded(true);
    setFailed(false);
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(event);
  };
  const handleImageError = (event) => {
    setLoaded(false);
    setFailed(true);
    onError === null || onError === void 0 ? void 0 : onError(event);
  };
  return (0, import_jsx_runtime15.jsxs)("div", _object_spread_props(_object_spread({
    style: _object_spread({
      width: size4,
      minWidth: size4,
      height: size4,
      borderRadius: (style === null || style === void 0 ? void 0 : style.borderRadius) || getBorderRadius(size4)
    }, style),
    className: classNames("tgui-30d8642662534eb5", loaded && "tgui-72bd4140eca37f53", className)
  }, restProps), {
    children: [
      hasSrc && (0, import_jsx_runtime15.jsx)("img", {
        alt,
        className: "tgui-1191c597a64dbd25",
        crossOrigin,
        decoding,
        loading,
        referrerPolicy,
        sizes,
        src,
        srcSet,
        useMap,
        onLoad: handleImageLoad,
        onError: handleImageError
      }),
      needShowFallbackIcon && (0, import_jsx_runtime15.jsx)("div", {
        className: "tgui-5ee2f1c6e1da49b5",
        children: fallbackIcon
      }),
      children
    ]
  }));
};
Image.Badge = ImageBadge;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Avatar/components/AvatarAcronym/AvatarAcronym.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Headline/Headline.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var Headline = (_param) => {
  var { className, Component } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime16.jsx)(Typography, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("tgui-e05fce4753086879", className),
    Component: Component || "h5"
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/LargeTitle/LargeTitle.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var LargeTitle = (_param) => {
  var { className, Component } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime17.jsx)(Typography, _object_spread_props(_object_spread({}, restProps), {
    Component: Component || "h1",
    className: classNames("tgui-c6d7432a5c12debe", className)
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Typography/Title/Title.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var titleLevelTags = {
  "1": "h2",
  "2": "h3",
  "3": "h4"
};
var titleLevelStyles = {
  "1": "tgui-2fc52ee93e8068a6",
  "2": "tgui-72c2a480384c4fb1",
  "3": "tgui-45c5f45d3e9105f4"
};
var Title = (_param) => {
  var { level = "2", className, Component } = _param, restProps = _object_without_properties(_param, [
    "level",
    "className",
    "Component"
  ]);
  return (0, import_jsx_runtime18.jsx)(Typography, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("tgui-da537051a4a87aec", titleLevelStyles[level], className),
    Component: Component || titleLevelTags[level]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Avatar/components/AvatarAcronym/AvatarAcronym.js
var AvatarAcronym = (_param) => {
  var { size: size4 } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  if (!size4) {
    return null;
  }
  if (size4 <= 28) {
    return (0, import_jsx_runtime19.jsx)(Caption, _object_spread({
      level: size4 <= 24 ? "2" : "1",
      weight: "1",
      caps: true
    }, restProps));
  }
  if (size4 === 40) {
    return (0, import_jsx_runtime19.jsx)(Headline, _object_spread({
      weight: "2",
      caps: true
    }, restProps));
  }
  if (size4 === 48) {
    return (0, import_jsx_runtime19.jsx)(Title, _object_spread({
      weight: "1",
      level: "3",
      caps: true
    }, restProps));
  }
  return (0, import_jsx_runtime19.jsx)(LargeTitle, _object_spread({
    weight: "1",
    caps: true
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Avatar/components/AvatarBadge/AvatarBadge.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var AvatarBadge = (_param) => {
  var { type, className } = _param, restProps = _object_without_properties(_param, [
    "type",
    "className"
  ]);
  if (type !== "number") {
    throw new Error('[ImageBadge]: Component supports only type="number"');
  }
  return (0, import_jsx_runtime20.jsx)(Badge, _object_spread({
    type: "number",
    className: classNames("tgui-54214e0db34f53c3", className)
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Avatar/Avatar.js
var Avatar = (_param) => {
  var { className, style, acronym, fallbackIcon, size: size4 } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "acronym",
    "fallbackIcon",
    "size"
  ]);
  return (0, import_jsx_runtime21.jsx)(Image, _object_spread({
    style: _object_spread({
      borderRadius: "50%"
    }, style),
    className: classNames("tgui-91c5537b51b490a7", acronym && "tgui-305551eb3f5abb68", className),
    fallbackIcon: acronym ? (0, import_jsx_runtime21.jsx)(AvatarAcronym, {
      size: size4,
      children: acronym
    }) : fallbackIcon,
    size: size4
  }, restProps));
};
Avatar.Badge = AvatarBadge;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/AvatarStack/AvatarStack.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var AvatarStack = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime22.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
    className: classNames("tgui-28e0a2576155be01"),
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Banner/Banner.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/icons/24/cancel.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var Icon24Cancel = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime23.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime23.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.5 4.44a.9.9 0 0 1 1.27 0L12 10.56l6.22-6.14a.9.9 0 0 1 1.27 1.28l-6.21 6.13 6.2 6.13a.9.9 0 0 1-1.26 1.28L12 13.1l-6.23 6.15a.9.9 0 1 1-1.26-1.28l6.2-6.13-6.2-6.13a.9.9 0 0 1-.01-1.27Z",
      fill: "#A2ACB0"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/28/close.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var Icon28Close = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime24.jsxs)("svg", _object_spread_props(_object_spread({
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime24.jsxs)("g", {
        clipPath: "url(#close_a)",
        fill: "currentColor",
        children: [
          (0, import_jsx_runtime24.jsx)("path", {
            d: "M14 28c7.66 0 14-6.35 14-14 0-7.66-6.35-14-14.01-14A14.1 14.1 0 0 0 0 14c0 7.65 6.35 14 14 14Z",
            fillOpacity: ".04"
          }),
          (0, import_jsx_runtime24.jsx)("path", {
            opacity: ".5",
            d: "M9.17 20C8.51 20 8 19.47 8 18.81c0-.31.11-.61.34-.83L12.31 14l-3.97-3.97A1.15 1.15 0 0 1 8 9.2c0-.67.51-1.17 1.17-1.17.33 0 .59.11.82.33l3.99 3.98 4.02-4c.24-.24.5-.34.81-.34.66 0 1.19.52 1.19 1.17 0 .33-.1.6-.36.85L15.67 14l3.96 3.97c.24.21.36.51.36.84 0 .66-.53 1.19-1.2 1.19-.33 0-.64-.11-.85-.34l-3.96-3.98-3.95 3.98c-.23.23-.53.34-.86.34Z",
            fillOpacity: ".8"
          })
        ]
      }),
      (0, import_jsx_runtime24.jsx)("defs", {
        children: (0, import_jsx_runtime24.jsx)("clipPath", {
          id: "close_a",
          children: (0, import_jsx_runtime24.jsx)("path", {
            fill: "#fff",
            d: "M0 0h28v28H0z"
          })
        })
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/28/close_ambient.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var Icon28CloseAmbient = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime25.jsxs)("svg", _object_spread_props(_object_spread({
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime25.jsxs)("g", {
        clipPath: "url(#close_ambient_a)",
        children: [
          (0, import_jsx_runtime25.jsx)("path", {
            d: "M14 28c7.66 0 14-6.35 14-14 0-7.66-6.35-14-14.01-14A14.1 14.1 0 0 0 0 14c0 7.65 6.35 14 14 14Z",
            fill: "#000",
            fillOpacity: ".1"
          }),
          (0, import_jsx_runtime25.jsx)("path", {
            d: "M9.17 20C8.51 20 8 19.47 8 18.81c0-.31.11-.61.34-.83L12.31 14l-3.97-3.97A1.15 1.15 0 0 1 8 9.2c0-.67.51-1.17 1.17-1.17.33 0 .59.11.82.33l3.99 3.98 4.02-4c.24-.24.5-.34.81-.34.66 0 1.19.52 1.19 1.17 0 .33-.1.6-.36.85L15.67 14l3.96 3.97c.24.21.36.51.36.84 0 .66-.53 1.19-1.2 1.19-.33 0-.64-.11-.85-.34l-3.96-3.98-3.95 3.98c-.23.23-.53.34-.86.34Z",
            fill: "#fff"
          })
        ]
      }),
      (0, import_jsx_runtime25.jsx)("defs", {
        children: (0, import_jsx_runtime25.jsx)("clipPath", {
          id: "close_ambient_a",
          children: (0, import_jsx_runtime25.jsx)("path", {
            fill: "#fff",
            d: "M0 0h28v28H0z"
          })
        })
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Banner/Banner.js
var Banner = (_param) => {
  var { type, before, header, subheader, description, background, className, children, onCloseIcon } = _param, restProps = _object_without_properties(_param, [
    "type",
    "before",
    "header",
    "subheader",
    "description",
    "background",
    "className",
    "children",
    "onCloseIcon"
  ]);
  const platform2 = usePlatform();
  const hasBackground = hasReactNode(background);
  return (0, import_jsx_runtime26.jsxs)("section", _object_spread_props(_object_spread({
    className: classNames("tgui-c3d21871b48e0ba3", platform2 === "ios" && "tgui-cefdf70a2d9648ea", platform2 === "base" && "tgui-7b260d7ad33f3ba0", hasBackground && "tgui-f80265c401d577b0", type === "inline" && "tgui-d67d90bbcab86e14", className)
  }, restProps), {
    children: [
      hasBackground && (0, import_jsx_runtime26.jsx)("div", {
        className: "tgui-11921b54915b369c",
        children: background
      }),
      before,
      (0, import_jsx_runtime26.jsxs)("div", {
        className: "tgui-a04b768cea14d789",
        children: [
          hasReactNode(header) && (0, import_jsx_runtime26.jsx)(Text, {
            className: "tgui-2646957e5c9379f3",
            weight: "2",
            children: header
          }),
          hasReactNode(subheader) && (0, import_jsx_runtime26.jsx)(Subheadline, {
            className: "tgui-62a759a0c54c3667",
            level: "2",
            children: subheader
          }),
          hasReactNode(description) && (0, import_jsx_runtime26.jsx)(Subheadline, {
            className: "tgui-1e638bcb841cdfbc",
            level: "2",
            children: description
          }),
          hasReactNode(children) && (0, import_jsx_runtime26.jsx)("div", {
            className: "tgui-5e0d89b3bc8342d8",
            children
          })
        ]
      }),
      onCloseIcon && (0, import_jsx_runtime26.jsxs)(Tappable, {
        onClick: onCloseIcon,
        className: "tgui-fa2f2ea4a4ffc035",
        Component: "div",
        children: [
          !hasBackground && (platform2 === "ios" ? (0, import_jsx_runtime26.jsx)(Icon24Cancel, {}) : (0, import_jsx_runtime26.jsx)(Icon28Close, {})),
          hasBackground && (0, import_jsx_runtime26.jsx)(Icon28CloseAmbient, {})
        ]
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Blockquote/Blockquote.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/icons/12/quote.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var Icon12Quote = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime27.jsx)("svg", _object_spread_props(_object_spread({
    width: "12",
    height: "12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime27.jsx)("path", {
      d: "M3.07 7.7c.14-.36-.14-.74-.5-.93A2 2 0 1 1 5.5 5V5c0 1.55-.27 2.67-.57 3.43a5.33 5.33 0 0 1-.67 1.22 1 1 0 0 1-1.53-1.3h.01l.07-.1c.06-.1.16-.28.26-.54ZM4.26 9.65ZM8.07 7.7c.14-.36-.14-.74-.5-.93A2 2 0 1 1 10.5 5V5c0 1.55-.27 2.67-.57 3.43a5.33 5.33 0 0 1-.67 1.22 1 1 0 0 1-1.53-1.3h.01l.07-.1c.06-.1.16-.28.26-.54ZM9.26 9.65Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/IconContainer/IconContainer.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var IconContainer = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime28.jsx)("div", _object_spread_props(_object_spread({
    className: classNames("tgui-6c9b3f1fd52a3108", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Blockquote/Blockquote.js
var Blockquote = (_param) => {
  var { type = "text", topRightIcon = (0, import_jsx_runtime29.jsx)(Icon12Quote, {}), className, children } = _param, restProps = _object_without_properties(_param, [
    "type",
    "topRightIcon",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime29.jsxs)("div", _object_spread_props(_object_spread({
    className: classNames("tgui-79024fcb6d81ad79", className)
  }, restProps), {
    children: [
      type === "text" ? (0, import_jsx_runtime29.jsx)(Subheadline, {
        className: "tgui-16ed20e7a6e2daa0",
        children
      }) : children,
      (0, import_jsx_runtime29.jsx)(IconContainer, {
        className: "tgui-bd5b6cd161834705",
        children: topRightIcon
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Button/Button.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var import_react17 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/Spinner.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/BaseSpinner/BaseSpinner.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/BaseSpinner/icons/large.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var IconLarge = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime30.jsxs)("svg", _object_spread_props(_object_spread({
    width: "44",
    height: "44",
    viewBox: "0 0 44 44",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime30.jsx)("use", {
        xlinkHref: "#spinner_44",
        fill: "none",
        children
      }),
      (0, import_jsx_runtime30.jsx)("symbol", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 44 44",
        id: "spinner_44",
        children: (0, import_jsx_runtime30.jsx)("path", {
          d: "M22 4C25.1288 4 28.2036 4.81556 30.9211 6.36624C33.6386 7.91693 35.9049 10.1492 37.4967 12.8429C39.0884 15.5365 39.9505 18.5986 39.9979 21.727C40.0454 24.8555 39.2765 27.9423 37.7672 30.683C36.258 33.4237 34.0603 35.7236 31.3911 37.356C28.7219 38.9884 25.6733 39.8968 22.5459 39.9917C19.4185 40.0866 16.3204 39.3647 13.5571 37.8971C10.7939 36.4296 8.46085 34.2671 6.78817 31.6229",
          stroke: "currentColor",
          strokeWidth: "4",
          strokeLinecap: "round"
        })
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/BaseSpinner/icons/medium.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var IconMedium = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime31.jsxs)("svg", _object_spread_props(_object_spread({
    width: "36",
    height: "36",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime31.jsx)("use", {
        xlinkHref: "#spinner_36",
        fill: "none",
        children
      }),
      (0, import_jsx_runtime31.jsx)("symbol", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 36 36",
        id: "spinner_36",
        children: (0, import_jsx_runtime31.jsx)("path", {
          d: "M18 4c2.4335 0 4.825.63432 6.9386 1.84041S28.815 8.7827 30.053 10.8778c1.238 2.0951 1.9085 4.4766 1.9454 6.9099.0369 2.4332-.5611 4.8341-1.735 6.9657-1.1739 2.1317-2.8831 3.9205-4.9592 5.1902-2.0761 1.2696-4.4472 1.9762-6.8796 2.05-2.4324.0738-4.842-.4877-6.9913-1.6292-2.14918-1.1414-3.96375-2.8234-5.26472-4.8799",
          stroke: "currentColor",
          strokeWidth: "3",
          strokeLinecap: "round"
        })
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/BaseSpinner/icons/small.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var IconSmall = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime32.jsxs)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime32.jsx)("use", {
        xlinkHref: "#spinner_24",
        fill: "none",
        children
      }),
      (0, import_jsx_runtime32.jsx)("symbol", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        id: "spinner_24",
        children: (0, import_jsx_runtime32.jsx)("path", {
          d: "M12 3c1.5644 0 3.1018.40778 4.4605 1.18312 1.3588.77535 2.492 1.89147 3.2878 3.23831.7959 1.34683 1.2269 2.87787 1.2507 4.44207.0237 1.5642-.3607 3.1076-1.1154 4.478-.7546 1.3703-1.8534 2.5203-3.188 3.3365-1.3347.8162-2.859 1.2704-4.4227 1.3179-1.5636.0474-3.11269-.3136-4.49433-1.0473-1.38163-.7338-2.54815-1.8151-3.38448-3.1371",
          stroke: "currentColor",
          strokeWidth: "2.2",
          strokeLinecap: "round"
        })
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/BaseSpinner/BaseSpinner.js
var componentBySize = {
  s: IconSmall,
  m: IconMedium,
  l: IconLarge
};
var rotateCenterBySize = {
  s: 12,
  m: 18,
  l: 22
};
var BaseSpinner = ({ size: size4 }) => {
  const Component = componentBySize[size4];
  const rotateCenter = rotateCenterBySize[size4];
  return (0, import_jsx_runtime33.jsx)(Component, {
    children: (0, import_jsx_runtime33.jsx)("animateTransform", {
      attributeName: "transform",
      attributeType: "XML",
      type: "rotate",
      from: `0 ${rotateCenter} ${rotateCenter}`,
      to: `360 ${rotateCenter} ${rotateCenter}`,
      dur: "0.7s",
      repeatCount: "indefinite"
    })
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/IOSSpinner/IOSSpinner.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/IOSSpinner/icons/large.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var IconLarge2 = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime34.jsxs)("svg", _object_spread_props(_object_spread({
    id: "l151:1947",
    width: "44",
    height: "44",
    viewBox: "0 0 44 44",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime34.jsx)("g", {
        transform: "matrix(1,0,0,1,0,0)",
        children: (0, import_jsx_runtime34.jsx)("g", {
          id: "l151:1947",
          opacity: "1",
          style: {
            mixBlendMode: "normal"
          },
          children: (0, import_jsx_runtime34.jsxs)("g", {
            children: [
              (0, import_jsx_runtime34.jsx)("defs", {
                children: (0, import_jsx_runtime34.jsx)("clipPath", {
                  id: "l151:1947_clipPath",
                  x: "-50%",
                  y: "-50%",
                  width: "200%",
                  height: "200%",
                  children: (0, import_jsx_runtime34.jsx)("path", {
                    d: "M0,0h44v0v44v0h-44v0v-44z",
                    fill: "white",
                    clipRule: "nonzero"
                  })
                })
              }),
              (0, import_jsx_runtime34.jsxs)("g", {
                clipPath: "url(#l151:1947_clipPath)",
                children: [
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(-0.7071067811865475,-0.7071067811865476,0.7071067811865476,-0.7071067811865475,9.2715,37.5564)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1985",
                      opacity: "0.837",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1985_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v10c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-10c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(1,0,0,1,20,29)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1980",
                      opacity: "0.467",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1980_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v9c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-9c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,24.8291,27.6569)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1982",
                      opacity: "0.153",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1982_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v10c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-10c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,29,24)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1984",
                      opacity: "0.049",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1984_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v9c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-9c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(-0.7071067811865475,-0.7071067811865476,0.7071067811865476,-0.7071067811865475,27.6592,19.1716)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1986",
                      opacity: "0.01",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1986_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v10c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-10c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(1,0,0,1,20,2)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1979",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1979_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v9c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-9c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,6.4473,9.2721)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1981",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1981_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v10c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-10c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime34.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,2,24)",
                    children: (0, import_jsx_runtime34.jsx)("g", {
                      id: "l151:1983",
                      opacity: "1",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime34.jsx)("g", {
                        children: (0, import_jsx_runtime34.jsx)("g", {
                          children: (0, import_jsx_runtime34.jsx)("path", {
                            id: "l151:1983_fill_path",
                            d: "M2,0v0c1.10457,0 2,0.89543 2,2v9c0,1.10457 -0.89543,2 -2,2v0c-1.10457,0 -2,-0.89543 -2,-2v-9c0,-1.10457 0.89543,-2 2,-2z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  })
                ]
              })
            ]
          })
        })
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1985",
        attributeName: "opacity",
        values: "0.837;0;1;0.8366;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.75;0.87;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1980",
        attributeName: "opacity",
        values: "0.467;0;1;0.4669;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.63;0.75;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1982",
        attributeName: "opacity",
        values: "0.153;0.05;1;0.1534;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.5;0.63;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1984",
        attributeName: "opacity",
        values: "0.049;0;1;0.0493;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.37;0.5;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1986",
        attributeName: "opacity",
        values: "0.01;0;1;0.0099;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.25;0.37;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1979",
        attributeName: "opacity",
        values: "0;0;1;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.25;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1981",
        attributeName: "opacity",
        values: "0;1;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime34.jsx)("animate", {
        href: "#l151:1983",
        attributeName: "opacity",
        values: "1;0;1",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/IOSSpinner/icons/medium.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var IconMedium2 = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime35.jsxs)("svg", _object_spread_props(_object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    id: "m151:1947",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, restProps), {
    children: [
      (0, import_jsx_runtime35.jsx)("g", {
        transform: "matrix(1,0,0,1,0,0)",
        children: (0, import_jsx_runtime35.jsx)("g", {
          id: "m151:1947",
          opacity: "1",
          style: {
            mixBlendMode: "normal"
          },
          children: (0, import_jsx_runtime35.jsxs)("g", {
            children: [
              (0, import_jsx_runtime35.jsx)("defs", {
                children: (0, import_jsx_runtime35.jsx)("clipPath", {
                  id: "m151:1947_clipPath",
                  x: "-50%",
                  y: "-50%",
                  width: "200%",
                  height: "200%",
                  children: (0, import_jsx_runtime35.jsx)("path", {
                    d: "M0,0h32v0v32v0h-32v0v-32z",
                    fill: "white",
                    clipRule: "nonzero"
                  })
                })
              }),
              (0, import_jsx_runtime35.jsxs)("g", {
                clipPath: "url(#151:1947_clipPath)",
                children: [
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(-0.7071067811865475,-0.7071067811865476,0.7071067811865476,-0.7071067811865475,6.7429,27.3137)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1985",
                      opacity: "0.837",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1985_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v7.1818c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-7.1818c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(1,0,0,1,14.5454,21.0909)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1980",
                      opacity: "0.467",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1980_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v6.4545c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-6.4545c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,18.0575,20.1141)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1982",
                      opacity: "0.153",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1982_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v7.1818c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-7.1818c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,21.0909,17.4545)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1984",
                      opacity: "0.049",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1984_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v6.4545c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-6.4545c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(-0.7071067811865475,-0.7071067811865476,0.7071067811865476,-0.7071067811865475,20.1157,13.943)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1986",
                      opacity: "0.01",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1986_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v7.1818c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-7.1818c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(1,0,0,1,14.5454,1.4545)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1979",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1979_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v6.4545c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-6.4545c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,4.6889,6.7433)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1981",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1981_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v7.1818c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-7.1818c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime35.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,1.4545,17.4545)",
                    children: (0, import_jsx_runtime35.jsx)("g", {
                      id: "m151:1983",
                      opacity: "1",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime35.jsx)("g", {
                        children: (0, import_jsx_runtime35.jsx)("g", {
                          children: (0, import_jsx_runtime35.jsx)("path", {
                            id: "m151:1983_fill_path",
                            d: "M1.5,0v0c0.82843,0 1.5,0.67157 1.5,1.5v6.4545c0,0.82843 -0.67157,1.5 -1.5,1.5v0c-0.82843,0 -1.5,-0.67157 -1.5,-1.5v-6.4545c0,-0.82843 0.67157,-1.5 1.5,-1.5z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  })
                ]
              })
            ]
          })
        })
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1985",
        attributeName: "opacity",
        values: "0.837;0;1;0.8366;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.75;0.87;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1980",
        attributeName: "opacity",
        values: "0.467;0;1;0.4669;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.63;0.75;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1982",
        attributeName: "opacity",
        values: "0.153;0.05;1;0.1534;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.5;0.63;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1984",
        attributeName: "opacity",
        values: "0.049;0;1;0.0493;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.37;0.5;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1986",
        attributeName: "opacity",
        values: "0.01;0;1;0.0099;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.25;0.37;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1979",
        attributeName: "opacity",
        values: "0;0;1;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.25;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1981",
        attributeName: "opacity",
        values: "0;1;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime35.jsx)("animate", {
        href: "#m151:1983",
        attributeName: "opacity",
        values: "1;0;1",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/IOSSpinner/icons/small.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var IconSmall2 = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return (0, import_jsx_runtime36.jsxs)("svg", _object_spread_props(_object_spread({
    id: "s151:1947",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime36.jsx)("g", {
        transform: "matrix(1,0,0,1,0,0)",
        children: (0, import_jsx_runtime36.jsx)("g", {
          id: "s151:1947",
          opacity: "1",
          style: {
            mixBlendMode: "normal"
          },
          children: (0, import_jsx_runtime36.jsxs)("g", {
            children: [
              (0, import_jsx_runtime36.jsx)("defs", {
                children: (0, import_jsx_runtime36.jsx)("clipPath", {
                  id: "s151:1947_clipPath",
                  x: "-50%",
                  y: "-50%",
                  width: "200%",
                  height: "200%",
                  children: (0, import_jsx_runtime36.jsx)("path", {
                    d: "M0,0h24v0v24v0h-24v0v-24z",
                    fill: "white",
                    clipRule: "nonzero"
                  })
                })
              }),
              (0, import_jsx_runtime36.jsxs)("g", {
                clipPath: "url(#151:1947_clipPath)",
                children: [
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(-0.7071067811865475,-0.7071067811865476,0.7071067811865476,-0.7071067811865475,5.64,19.78)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1985",
                      opacity: "0.837",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1985_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(1,0,0,1,11,15)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1980",
                      opacity: "0.467",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1980_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,13.41,14.83)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1982",
                      opacity: "0.153",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1982_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,15,13)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1984",
                      opacity: "0.049",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1984_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(1,0,0,1,13.41,4.22)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s597:11660",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s597:11660_fill_path",
                            d: "M2.0341,6.01101c-0.46533,0.46533 -1.21977,0.46533 -1.6851,0c-0.46533,-0.46533 -0.46533,-1.21977 0,-1.6851l3.97691,-3.97691c0.46533,-0.46533 1.21977,-0.46533 1.6851,0c0.46533,0.46533 0.46533,1.21977 0,1.6851z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(1,0,0,1,11,1.9998)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1979",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1979_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(0.7071067811865476,-0.7071067811865475,0.7071067811865475,0.7071067811865476,4.22,5.64)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1981",
                      opacity: "0",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1981_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  }),
                  (0, import_jsx_runtime36.jsx)("g", {
                    transform: "matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,2.0003,13)",
                    children: (0, import_jsx_runtime36.jsx)("g", {
                      id: "s151:1983",
                      opacity: "1",
                      style: {
                        mixBlendMode: "normal"
                      },
                      children: (0, import_jsx_runtime36.jsx)("g", {
                        children: (0, import_jsx_runtime36.jsx)("g", {
                          children: (0, import_jsx_runtime36.jsx)("path", {
                            id: "s151:1983_fill_path",
                            d: "M1,0v0c0.55228,0 1,0.44772 1,1v5c0,0.55228 -0.44772,1 -1,1v0c-0.55228,0 -1,-0.44772 -1,-1v-5c0,-0.55228 0.44772,-1 1,-1z",
                            fillRule: "nonzero",
                            fill: "currentColor",
                            fillOpacity: "1",
                            style: {
                              mixBlendMode: "normal"
                            }
                          })
                        })
                      })
                    })
                  })
                ]
              })
            ]
          })
        })
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1985",
        attributeName: "opacity",
        values: "0.837;0;1;0.8366;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.75;0.87;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1980",
        attributeName: "opacity",
        values: "0.467;0;1;0.4669;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.63;0.75;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1982",
        attributeName: "opacity",
        values: "0.153;0.05;1;0.1534;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.5;0.63;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1984",
        attributeName: "opacity",
        values: "0.049;0;1;0.0493;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.37;0.5;1;1;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s597:11660",
        attributeName: "opacity",
        values: "0;0;1;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.25;0.37;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1979",
        attributeName: "opacity",
        values: "0;0;1;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.25;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1981",
        attributeName: "opacity",
        values: "0;1;0;0",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.13;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      }),
      (0, import_jsx_runtime36.jsx)("animate", {
        href: "#s151:1983",
        attributeName: "opacity",
        values: "1;0;1",
        dur: "0.8s",
        repeatCount: "indefinite",
        calcMode: "spline",
        keyTimes: "0;0.89;1",
        keySplines: "0.5 0.35 0.15 1;0.5 0.35 0.15 1",
        additive: "replace",
        fill: "freeze"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/components/IOSSpinner/IOSSpinner.js
var IOSSpinner = ({ size: size4 }) => {
  switch (size4) {
    case "l":
      return (0, import_jsx_runtime37.jsx)(IconLarge2, {});
    case "m":
      return (0, import_jsx_runtime37.jsx)(IconMedium2, {});
    default:
      return (0, import_jsx_runtime37.jsx)(IconSmall2, {});
  }
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spinner/Spinner.js
var sizeStyles = {
  s: "tgui-421d6dab8d2c78c1",
  m: "tgui-a636342f03bb5c08",
  l: "tgui-a53583a4b6d8fde0"
};
var Spinner = ({ size: size4 = "m", className }) => {
  const platform2 = usePlatform();
  const Component = platform2 === "ios" ? IOSSpinner : BaseSpinner;
  return (0, import_jsx_runtime38.jsx)("div", {
    role: "status",
    className: classNames("tgui-0ac8c3540e603b63", platform2 === "ios" && "tgui-562a3eae646b486d", sizeStyles[size4], className),
    children: (0, import_jsx_runtime38.jsx)(Component, {
      size: size4
    })
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Button/components/ButtonTypography/ButtonTypography.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var ButtonTypography = (_param) => {
  var { size: size4 } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  if (size4 === "l") {
    return (0, import_jsx_runtime39.jsx)(Text, _object_spread({
      weight: "2"
    }, restProps));
  }
  return (0, import_jsx_runtime39.jsx)(Subheadline, _object_spread({
    level: "2",
    weight: "2"
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Button/Button.js
var modeStyles2 = {
  filled: "tgui-8a1ca9efa24f4809",
  bezeled: "tgui-91bda9a36246a33c",
  plain: "tgui-48956537c34690db",
  gray: "tgui-93106efd6b6d66ee",
  outline: "tgui-e884e36ff1faa596",
  white: "tgui-ba6d30cc81e39ae5"
};
var sizeStyles2 = {
  s: "tgui-13f23a224303ddaa",
  m: "tgui-1a16a49d89076ff4",
  l: "tgui-9cef742a22f195c9"
};
var Button = (0, import_react17.forwardRef)((_param, ref) => {
  var { type, size: size4 = "m", before, after, stretched, children, className, mode = "filled", loading, Component = "button" } = _param, restProps = _object_without_properties(_param, [
    "type",
    "size",
    "before",
    "after",
    "stretched",
    "children",
    "className",
    "mode",
    "loading",
    "Component"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime40.jsxs)(Tappable, _object_spread_props(_object_spread({
    ref,
    type: type || "button",
    Component,
    className: classNames("tgui-117e77cd385a9c8d", mode && modeStyles2[mode], size4 && sizeStyles2[size4], platform2 === "ios" && "tgui-55e8aa7f5cea2280", stretched && "tgui-726846958fe7f4a0", loading && "tgui-490cb0f5ec4998f3", className)
  }, restProps), {
    children: [
      loading && (0, import_jsx_runtime40.jsx)(Spinner, {
        className: "tgui-014f2b7d196b090d",
        size: "s"
      }),
      hasReactNode(before) && (0, import_jsx_runtime40.jsx)("div", {
        className: "tgui-06cc94d03a7c4dd7",
        children: before
      }),
      (0, import_jsx_runtime40.jsx)(ButtonTypography, {
        className: "tgui-5f6014c0f063b6de",
        size: size4,
        children
      }),
      hasReactNode(after) && (0, import_jsx_runtime40.jsx)("div", {
        className: "tgui-8310172a5320ab71",
        children: after
      })
    ]
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/Card.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var import_react20 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/components/CardCell/CardCell.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var import_react19 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/CardContext.js
var import_react18 = __toESM(require_react());
var CardContext = (0, import_react18.createContext)({
  type: "plain"
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/components/CardCell/CardCell.js
var CardCell = (_param) => {
  var { children, subtitle, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "subtitle",
    "className"
  ]);
  const cardContext = (0, import_react19.useContext)(CardContext);
  return (0, import_jsx_runtime41.jsx)(Cell, _object_spread_props(_object_spread({
    className: classNames("tgui-80c6a0ba7b3c11fd", cardContext.type === "ambient" && "tgui-814d1971a92687e3", className),
    subtitle: hasReactNode(subtitle) && (0, import_jsx_runtime41.jsx)("span", {
      className: "tgui-422c21c917cc0873",
      children: subtitle
    })
  }, restProps), {
    children: hasReactNode(children) && (0, import_jsx_runtime41.jsx)("span", {
      className: "tgui-27c5a061c5f35c04",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/components/CardChip/CardChip.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Chip/Chip.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var modeStyles3 = {
  elevated: "tgui-b8b077d7e3491b30",
  mono: "tgui-ccc3e4a302799418",
  outline: "tgui-fdfccf8f92c11530"
};
var Chip = (_param) => {
  var { mode = "elevated", before, after, className, children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "before",
    "after",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime42.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: "div",
    interactiveAnimation: "opacity",
    className: classNames("tgui-6372c64c79ad2959", modeStyles3[mode], className)
  }, restProps), {
    children: [
      hasReactNode(before) && (0, import_jsx_runtime42.jsx)("div", {
        className: "tgui-0d7ce20ebc0fc7aa",
        children: before
      }),
      (0, import_jsx_runtime42.jsx)(Subheadline, {
        className: "tgui-9c7ff8cd23a6ea9a",
        level: platform2 === "ios" ? "2" : "1",
        weight: "2",
        children
      }),
      hasReactNode(after) && (0, import_jsx_runtime42.jsx)("div", {
        className: "tgui-67f596882eb2b6ab",
        children: after
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/components/CardChip/CardChip.js
var CardChip = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime43.jsx)(Chip, _object_spread({
    className: classNames("tgui-79efb12936705a6f", className)
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Card/Card.js
var Card = (0, import_react20.forwardRef)((_param, ref) => {
  var { type = "plain", className, children } = _param, restProps = _object_without_properties(_param, [
    "type",
    "className",
    "children"
  ]);
  const contextValue = useObjectMemo({
    type
  });
  return (0, import_jsx_runtime44.jsx)(CardContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime44.jsx)("article", _object_spread_props(_object_spread({
      ref,
      className: classNames("tgui-dbf261f4b3046bb3", type === "ambient" && "tgui-c6ad96fdf8ce4b28", className)
    }, restProps), {
      children
    }))
  });
});
Card.Cell = CardCell;
Card.Chip = CardChip;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/components/ButtonCell/ButtonCell.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var import_react21 = __toESM(require_react());
var ButtonCell = (0, import_react21.forwardRef)((_param, ref) => {
  var { mode = "default", before, after, className, children, Component } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "before",
    "after",
    "className",
    "children",
    "Component"
  ]);
  const platform2 = usePlatform();
  const Typography2 = platform2 === "ios" ? Subheadline : Text;
  return (0, import_jsx_runtime45.jsxs)(Tappable, _object_spread_props(_object_spread({
    ref,
    Component: Component || "button",
    className: classNames("tgui-a8ce18a8594cea9b", mode === "destructive" && "tgui-6e7ca796043fe6ca", platform2 === "ios" && "tgui-f464dba82cb8b46e", className)
  }, restProps), {
    children: [
      hasReactNode(before) && before,
      hasReactNode(children) && (0, import_jsx_runtime45.jsx)(Typography2, {
        children
      }),
      hasReactNode(after) && after
    ]
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/components/Info/Info.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var typeStyles2 = {
  text: "tgui-c5be765fabc1327f",
  avatarStack: "tgui-437ab2028f14c95c"
};
var Info = (_param) => {
  var { type = "text", subtitle, avatarStack, children, className } = _param, restProps = _object_without_properties(_param, [
    "type",
    "subtitle",
    "avatarStack",
    "children",
    "className"
  ]);
  const isAvatarStack = type === "avatarStack";
  const isText = type === "text";
  return (0, import_jsx_runtime46.jsxs)("div", _object_spread_props(_object_spread({
    className: classNames("tgui-70fc390c70476f82", typeStyles2[type], className)
  }, restProps), {
    children: [
      isAvatarStack && hasReactNode(avatarStack) && avatarStack,
      hasReactNode(children) && (0, import_jsx_runtime46.jsx)(Text, {
        children
      }),
      isText && hasReactNode(subtitle) && (0, import_jsx_runtime46.jsx)(Subheadline, {
        className: "tgui-4af039094fb946b4",
        level: "2",
        plain: false,
        children: subtitle
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/components/Navigation/Navigation.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/icons/16/chevron.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var Icon16Chevron = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime47.jsx)("svg", _object_spread_props(_object_spread({
    width: "16",
    height: "16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime47.jsx)("path", {
      d: "m6 3 5 5-5 5",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Cell/components/Navigation/Navigation.js
var Navigation = ({ className, children }) => {
  const platform2 = usePlatform();
  const hasChildren = hasReactNode(children);
  return (0, import_jsx_runtime48.jsxs)("div", {
    className: classNames("tgui-97dd747d03e9d3e0", className),
    children: [
      hasChildren && (0, import_jsx_runtime48.jsx)(Text, {
        className: "tgui-64a5a0dc5509605e",
        children
      }),
      (!hasChildren || platform2 === "ios") && (0, import_jsx_runtime48.jsx)(Icon16Chevron, {
        className: "tgui-3b026a2674eb3f4c"
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/IconButton/IconButton.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var modeStyles4 = {
  bezeled: "tgui-93cba8aff2e72079",
  plain: "tgui-08ef1486bc111162",
  gray: "tgui-2250ff52f0b5cf71",
  outline: "tgui-53781f3cf83e8be1"
};
var sizeStyles3 = {
  s: "tgui-b92d762e02762017",
  m: "tgui-024dfe77a8f2cfb0",
  l: "tgui-8ca1879e1128c105"
};
var IconButton = (_param) => {
  var { size: size4 = "m", mode = "bezeled", className, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "mode",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime49.jsx)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    className: classNames("tgui-dda0e80fdf796ba5", modeStyles4[mode], sizeStyles3[size4], className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/InlineButtons/InlineButtons.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var import_react24 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/InlineButtons/components/InlineButtonsItem/InlineButtonsItem.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var import_react23 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/InlineButtons/InlineButtonsContext.js
var import_react22 = __toESM(require_react());
var InlineButtonsContext = (0, import_react22.createContext)({});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/InlineButtons/components/InlineButtonsItem/InlineButtonsItem.js
var modeStyles5 = {
  bezeled: "tgui-99a630d0096f2169",
  gray: "tgui-30bf4976f818e8bf"
};
var InlineButtonsItem = (_param) => {
  var { mode: propsMode = "plain", className, text, children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "className",
    "text",
    "children"
  ]);
  const platform2 = usePlatform();
  const { mode: inheritMode } = (0, import_react23.useContext)(InlineButtonsContext);
  const mode = inheritMode || propsMode;
  return (0, import_jsx_runtime50.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    className: classNames("tgui-c5545e0bc6105e48", platform2 === "ios" && "tgui-bf32cd3c110b8729", mode !== "plain" && modeStyles5[mode], className)
  }, restProps), {
    children: [
      children,
      hasReactNode(text) && (0, import_jsx_runtime50.jsx)(Caption, {
        className: "tgui-c0c9bf3b1a53a8a4",
        level: "1",
        weight: "2",
        children: text
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/InlineButtons/InlineButtons.js
var InlineButtons = (0, import_react24.forwardRef)((_param, ref) => {
  var { mode, className, children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  const contextValue = useObjectMemo({
    mode
  });
  return (0, import_jsx_runtime51.jsx)("div", _object_spread_props(_object_spread({
    ref,
    className: classNames("tgui-39e9f02ce4b4b950", platform2 === "ios" && "tgui-b3d7f75461a64b76", className)
  }, restProps), {
    children: (0, import_jsx_runtime51.jsx)(InlineButtonsContext.Provider, {
      value: contextValue,
      children
    })
  }));
});
InlineButtons.Item = InlineButtonsItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/List/List.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var List = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime52.jsx)("div", _object_spread_props(_object_spread({
    className: classNames("tgui-389a43acd684137a", platform2 === "ios" && "tgui-cfed40fe81d34ad5", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Placeholder/Placeholder.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var Placeholder = (_param) => {
  var { children, header, description, className, action } = _param, restProps = _object_without_properties(_param, [
    "children",
    "header",
    "description",
    "className",
    "action"
  ]);
  const hasHeader = hasReactNode(header);
  const hasDescription = hasReactNode(description);
  return (0, import_jsx_runtime53.jsxs)("section", _object_spread_props(_object_spread({
    className: classNames("tgui-e5c3a5b87f8b1f46", className)
  }, restProps), {
    children: [
      hasReactNode(children) && children,
      (hasHeader || hasDescription) && (0, import_jsx_runtime53.jsxs)("dl", {
        className: "tgui-9c3dbc0ef84585d4",
        children: [
          hasHeader && (0, import_jsx_runtime53.jsx)(Title, {
            Component: "dt",
            level: "3",
            weight: "2",
            children: header
          }),
          hasDescription && (0, import_jsx_runtime53.jsx)(Text, {
            className: "tgui-87cd6af55f73428d",
            Component: "dd",
            children: description
          })
        ]
      }),
      hasReactNode(action) && action
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/Section.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var import_react25 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Misc/Divider/Divider.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var Divider = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return (0, import_jsx_runtime54.jsx)("hr", _object_spread({
    className: classNames("tgui-8af0d10d5540c6cc", className)
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/components/SectionFooter/SectionFooter.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var FooterTypography = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  const platform2 = usePlatform();
  if (platform2 === "ios") {
    return (0, import_jsx_runtime55.jsx)(Caption, _object_spread({}, restProps));
  }
  return (0, import_jsx_runtime55.jsx)(Subheadline, _object_spread({
    level: "2"
  }, restProps));
};
var SectionFooter = (_param) => {
  var { className, children, centered } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children",
    "centered"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime55.jsx)("footer", _object_spread_props(_object_spread({
    className: classNames("tgui-dbb364e8ced00cc8", platform2 === "ios" && "tgui-8c4c6f82ba895475", centered && "tgui-8ebba379083b615a", className)
  }, restProps), {
    children: (0, import_jsx_runtime55.jsx)(FooterTypography, {
      className: "tgui-67471b69da3e3062",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/components/SectionHeader/SectionHeader.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/components/SectionHeader/hooks/useHeaderComponents.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var useHeaderComponents = () => {
  const platform2 = usePlatform();
  const Default = (_param) => {
    var restProps = _extends({}, _object_destructuring_empty(_param));
    if (platform2 === "ios") {
      return (0, import_jsx_runtime56.jsx)(Caption, _object_spread({
        caps: true
      }, restProps));
    }
    return (0, import_jsx_runtime56.jsx)(Subheadline, _object_spread({
      level: "2",
      weight: "2"
    }, restProps));
  };
  const Large = (_param) => {
    var restProps = _extends({}, _object_destructuring_empty(_param));
    if (platform2 === "ios") {
      return (0, import_jsx_runtime56.jsx)(Subheadline, _object_spread({
        level: "1",
        weight: "2"
      }, restProps));
    }
    return (0, import_jsx_runtime56.jsx)(Text, _object_spread({
      weight: "2"
    }, restProps));
  };
  return {
    Default,
    Large
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/components/SectionHeader/SectionHeader.js
var SectionHeader = (_param) => {
  var { large, className, children } = _param, restProps = _object_without_properties(_param, [
    "large",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  const { Default, Large } = useHeaderComponents();
  const Component = large ? Large : Default;
  return (0, import_jsx_runtime57.jsx)("header", _object_spread_props(_object_spread({
    className: classNames("tgui-d0251b46536ac046", platform2 === "ios" && "tgui-b7217abb24e8763a", large && "tgui-34fd1a25cc171439", className)
  }, restProps), {
    children: (0, import_jsx_runtime57.jsx)(Component, {
      Component: "h1",
      className: "tgui-9c200683b316fde6",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Section/Section.js
var Section = (_param) => {
  var { header, footer, className, children } = _param, restProps = _object_without_properties(_param, [
    "header",
    "footer",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  const headerWithWrapper = isPrimitiveReactNode(header) ? (0, import_jsx_runtime58.jsx)(SectionHeader, {
    children: header
  }) : header;
  const footerWithWrapper = isPrimitiveReactNode(footer) ? (0, import_jsx_runtime58.jsx)(SectionFooter, {
    children: footer
  }) : footer;
  return (0, import_jsx_runtime58.jsxs)("section", _object_spread_props(_object_spread({
    className: classNames("tgui-3dfa44f9f78f9a22", platform2 === "base" && "tgui-8e15431b81f6601e", platform2 === "ios" && "tgui-97eca24324122dbc", className)
  }, restProps), {
    children: [
      (0, import_jsx_runtime58.jsxs)("div", {
        className: "tgui-db9be63c4fecf79b",
        children: [
          headerWithWrapper,
          (0, import_jsx_runtime58.jsx)("div", {
            className: "tgui-4b78bed6e925088e",
            children: import_react25.Children.map(children, (child, index2) => (0, import_jsx_runtime58.jsxs)(import_jsx_runtime58.Fragment, {
              children: [
                child,
                index2 < import_react25.Children.count(children) - 1 && (0, import_jsx_runtime58.jsx)(Divider, {
                  className: "tgui-a6d406c4dc060899"
                })
              ]
            }))
          })
        ]
      }),
      footerWithWrapper
    ]
  }));
};
Section.Header = SectionHeader;
Section.Footer = SectionFooter;

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Steps/Steps.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var Steps = ({ className, count: count3, progress }) => (0, import_jsx_runtime59.jsx)("div", {
  className: classNames("tgui-f492b616576c67fb", className),
  children: Array.from({
    length: count3
  }, (_, i) => (0, import_jsx_runtime59.jsx)("div", {
    className: classNames("tgui-d45985ba4cb27e5f", {
      ["tgui-352b8d247f473986"]: i < progress
    })
  }, i))
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Timeline/Timeline.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var import_react26 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/HorizontalScroll/HorizontalScroll.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var HorizontalScroll = (_param) => {
  var { Component = "div", className, children } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime60.jsx)(Component, _object_spread_props(_object_spread({
    className: classNames("tgui-4614301efc783534", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Timeline/components/TimelineItem/TimelineItem.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var modeStyles6 = {
  active: "tgui-dcd66bc07faad440",
  "pre-active": "tgui-581d134185fd28b4"
};
var TimelineItem = (_param) => {
  var { header, horizontal, mode, className, children } = _param, restProps = _object_without_properties(_param, [
    "header",
    "horizontal",
    "mode",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime61.jsxs)("li", _object_spread_props(_object_spread({
    className: classNames("tgui-caaaa27ccfa566b7", mode && modeStyles6[mode], platform2 === "ios" && "tgui-566b727e7a35e935", horizontal && "tgui-f461f2eeb28c21d0", className)
  }, restProps), {
    children: [
      (0, import_jsx_runtime61.jsxs)("div", {
        className: "tgui-0f46575488c31b93",
        children: [
          (0, import_jsx_runtime61.jsx)("div", {
            className: "tgui-3fc2f0d7045d23d8"
          }),
          (0, import_jsx_runtime61.jsx)("div", {
            className: "tgui-d7ba9c56743387af"
          })
        ]
      }),
      (0, import_jsx_runtime61.jsxs)("div", {
        className: "tgui-bf9f87dd32ecad81",
        children: [
          (0, import_jsx_runtime61.jsx)(Text, {
            className: "tgui-2b850faa8f3a520a",
            weight: "2",
            children: header
          }),
          (0, import_jsx_runtime61.jsx)(Subheadline, {
            level: platform2 === "ios" ? "1" : "2",
            className: "tgui-b9a4d9afcd70e355",
            children
          })
        ]
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Blocks/Timeline/Timeline.js
var Timeline = (_param) => {
  var { active, horizontal, className, children } = _param, restProps = _object_without_properties(_param, [
    "active",
    "horizontal",
    "className",
    "children"
  ]);
  const getChildMode = (childNumber) => {
    if (!active) {
      return void 0;
    }
    if (childNumber <= active) {
      return "active";
    }
    if (childNumber === active + 1) {
      return "pre-active";
    }
    return void 0;
  };
  const Component = horizontal ? HorizontalScroll : "ul";
  return (0, import_jsx_runtime62.jsx)(Component, _object_spread_props(_object_spread({
    className: classNames("tgui-b53f1370d519b689", horizontal && "tgui-732e8859c58ffb77", className)
  }, restProps), {
    children: import_react26.Children.map(children, (child, index2) => {
      if ((0, import_react26.isValidElement)(child)) {
        return (0, import_react26.cloneElement)(child, _object_spread({
          mode: getChildMode(index2 + 1),
          horizontal
        }, child.props));
      }
      return child;
    })
  }));
};
Timeline.Item = TimelineItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/CircularProgress/CircularProgress.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/CircularProgress/helpers/getCircleAttributes.js
var getCircleAttributes = (size4) => {
  switch (size4) {
    case "large":
      return {
        size: 56,
        strokeWidth: 4,
        radius: 18
      };
    case "medium":
      return {
        size: 36,
        strokeWidth: 3,
        radius: 14
      };
    case "small":
      return {
        size: 28,
        strokeWidth: 3,
        radius: 10
      };
    default:
      return void 0;
  }
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/CircularProgress/CircularProgress.js
var CircularProgress = ({ size: size4 = "medium", progress = 0 }) => {
  const circleAttributes = getCircleAttributes(size4);
  if (!circleAttributes) {
    return null;
  }
  const circumference = 2 * Math.PI * circleAttributes.radius;
  const circleSize = circleAttributes.size / 2;
  return (0, import_jsx_runtime63.jsxs)("svg", {
    className: "tgui-81a5164cd16c05d5",
    width: circleAttributes.size,
    height: circleAttributes.size,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime63.jsx)("circle", {
        cx: circleSize,
        cy: circleSize,
        r: circleAttributes.radius,
        strokeOpacity: ".1",
        strokeWidth: circleAttributes.strokeWidth,
        fill: "none"
      }),
      (0, import_jsx_runtime63.jsx)("circle", {
        fill: "none",
        cx: circleSize,
        cy: circleSize,
        r: circleAttributes.radius,
        strokeWidth: circleAttributes.strokeWidth,
        strokeLinecap: "round",
        strokeDasharray: circumference,
        strokeDashoffset: circumference * ((100 - progress) / 100)
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Progress/Progress.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/math.js
var clamp = (value, min2, max2) => {
  return Math.max(min2, Math.min(value, max2));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Progress/Progress.js
var PROGRESS_MIN_VALUE = 0;
var PROGRESS_MAX_VALUE = 100;
var Progress = (_param) => {
  var { value = 0, className } = _param, restProps = _object_without_properties(_param, [
    "value",
    "className"
  ]);
  const platform2 = usePlatform();
  const progress = clamp(value, PROGRESS_MIN_VALUE, PROGRESS_MAX_VALUE);
  const title = `${progress} / ${PROGRESS_MAX_VALUE}`;
  return (0, import_jsx_runtime64.jsx)("div", _object_spread_props(_object_spread({
    title,
    role: "progressbar",
    "aria-valuenow": value,
    "aria-valuemin": PROGRESS_MIN_VALUE,
    "aria-valuemax": PROGRESS_MAX_VALUE,
    className: classNames("tgui-ced47fd163a53511", platform2 === "base" && "tgui-44060f289fdbdb84", className)
  }, restProps), {
    children: (0, import_jsx_runtime64.jsx)("div", {
      "aria-hidden": true,
      className: "tgui-027278a6d6708965",
      style: {
        width: `${progress}%`
      }
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Skeleton/Skeleton.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var Skeleton = (_param) => {
  var { withoutAnimation, visible, className, children } = _param, restProps = _object_without_properties(_param, [
    "withoutAnimation",
    "visible",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime65.jsx)("div", _object_spread_props(_object_spread({
    className: classNames("tgui-97f2df57786b02dc", visible && "tgui-3eb6091f664c15d6", withoutAnimation && "tgui-ecf101b3117a96c8", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Snackbar/Snackbar.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var import_react28 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/RootRenderer/RootRenderer.js
var import_react27 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var RootRenderer = ({ children }) => {
  const { portalContainer } = useAppRootContext();
  if (!(portalContainer === null || portalContainer === void 0 ? void 0 : portalContainer.current)) {
    return (0, import_react27.isValidElement)(children) ? children : null;
  }
  return (0, import_react_dom.createPortal)(children, portalContainer.current);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Snackbar/components/SnackbarButton/SnackbarButton.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var SnackbarButton = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime66.jsx)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    className: classNames("tgui-4d26fba7185ffa9f", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Snackbar/Snackbar.js
var TRANSITION_FINISH_DURATION = 320;
var Snackbar = (_param) => {
  var { before, after, description, link, children, className, duration = 4e3, onClose } = _param, restProps = _object_without_properties(_param, [
    "before",
    "after",
    "description",
    "link",
    "children",
    "className",
    "duration",
    "onClose"
  ]);
  const platform2 = usePlatform();
  const [closing, setClosing] = (0, import_react28.useState)(false);
  const close = () => {
    setClosing(true);
    setTimeout(onClose, TRANSITION_FINISH_DURATION);
  };
  const closeTimeout = useTimeout(close, duration);
  (0, import_react28.useEffect)(() => closeTimeout.set(), [
    closeTimeout
  ]);
  return (0, import_jsx_runtime67.jsx)(RootRenderer, {
    children: (0, import_jsx_runtime67.jsx)("div", _object_spread_props(_object_spread({
      className: classNames("tgui-bed09b0692380ce7", platform2 === "ios" && "tgui-c2ca59c94a46245e", closing && "tgui-a1e25a2488982fc5", className)
    }, restProps), {
      children: (0, import_jsx_runtime67.jsxs)("div", {
        className: "tgui-a869502f11f22b6c",
        children: [
          hasReactNode(before) && (0, import_jsx_runtime67.jsx)("div", {
            className: "tgui-229bfa1a0a8ac43f",
            children: before
          }),
          (0, import_jsx_runtime67.jsxs)("div", {
            className: "tgui-7d8f183ba67229e9",
            children: [
              hasReactNode(children) && (0, import_jsx_runtime67.jsx)(Caption, {
                weight: "2",
                children
              }),
              hasReactNode(description) && (0, import_jsx_runtime67.jsx)(Caption, {
                children: description
              }),
              hasReactNode(link) && (0, import_jsx_runtime67.jsx)(Caption, {
                children: link
              })
            ]
          }),
          hasReactNode(after) && (0, import_jsx_runtime67.jsx)("div", {
            className: "tgui-093aea87229643ac",
            children: after
          })
        ]
      })
    }))
  });
};
Snackbar.Button = SnackbarButton;

// node_modules/@telegram-apps/telegram-ui/dist/components/Feedback/Spoiler/Spoiler.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
var import_react29 = __toESM(require_react());
var Spoiler = (_param) => {
  var { visible = false, className, children } = _param, restProps = _object_without_properties(_param, [
    "visible",
    "className",
    "children"
  ]);
  const [isVisible, setIsVisible] = (0, import_react29.useState)(visible);
  (0, import_react29.useEffect)(() => {
    setIsVisible(visible);
  }, [
    visible
  ]);
  const toggle = () => setIsVisible(!isVisible);
  return (
    // It's a spoiler component, content inside is available for screen readers
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    (0, import_jsx_runtime68.jsx)("div", _object_spread_props(_object_spread({}, restProps), {
      className: classNames("tgui-86f452d8e92a2075", isVisible && "tgui-aff2a6268e887037", className),
      onClick: callMultiple(toggle, restProps.onClick),
      onKeyDown: callMultiple(toggle, restProps.onKeyDown),
      children
    }))
  );
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Checkbox/Checkbox.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/VisuallyHidden/VisuallyHidden.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var import_react30 = __toESM(require_react());
var VisuallyHidden = (0, import_react30.forwardRef)((_param, ref) => {
  var { Component = "span", className } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "className"
  ]);
  return (0, import_jsx_runtime69.jsx)(Component, _object_spread_props(_object_spread({}, restProps), {
    ref,
    className: classNames("tgui-b9fd8cdf929947df", className)
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Checkbox/icons/checkbox.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var IconCheckbox = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime70.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime70.jsx)("path", {
      d: "M6.4 1h7.2c1.14 0 1.93 0 2.55.05.6.05.95.14 1.21.28a3 3 0 0 1 1.31 1.3c.14.27.23.62.28 1.22.05.62.05 1.41.05 2.55v7.2c0 1.14 0 1.93-.05 2.55-.05.6-.14.95-.28 1.21a3 3 0 0 1-1.3 1.31c-.27.14-.62.23-1.22.28-.62.05-1.41.05-2.55.05H6.4c-1.14 0-1.93 0-2.55-.05-.6-.05-.95-.14-1.21-.28a3 3 0 0 1-1.31-1.3 3.2 3.2 0 0 1-.28-1.22A34.7 34.7 0 0 1 1 13.6V6.4c0-1.14 0-1.93.05-2.55.05-.6.14-.95.28-1.21a3 3 0 0 1 1.3-1.31 3.2 3.2 0 0 1 1.22-.28C4.47 1 5.26 1 6.4 1Z",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Checkbox/icons/checkbox_checked.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());
var IconCheckboxChecked = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime71.jsxs)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime71.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M.48 2.87C0 3.88 0 5.2 0 7.8v4.4c0 2.61 0 3.92.48 4.93a5 5 0 0 0 2.4 2.4c1 .47 2.3.47 4.92.47h4.4c2.61 0 3.92 0 4.93-.48a5 5 0 0 0 2.4-2.4c.47-1 .47-2.3.47-4.92V7.8c0-2.61 0-3.92-.48-4.93a5 5 0 0 0-2.4-2.4C16.13 0 14.83 0 12.2 0H7.8C5.19 0 3.88 0 2.87.48a5 5 0 0 0-2.4 2.4ZM15.7 7.46a1 1 0 0 0-1.42-1.42L8 12.34l-2.3-2.3a1 1 0 1 0-1.4 1.42l3 3a1 1 0 0 0 1.4 0l7-7Z",
        fill: "currentColor"
      }),
      (0, import_jsx_runtime71.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M15.7 7.46a1 1 0 0 0-1.4-1.42L8 12.34l-2.3-2.3a1 1 0 1 0-1.4 1.42l3 3a1 1 0 0 0 1.4 0l7-7Z",
        fill: "#fff"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Checkbox/icons/checkbox_indeterminate.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
var IconCheckboxIndeterminate = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime72.jsxs)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime72.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6.4 0h7.2c2.24 0 3.36 0 4.22.44a4 4 0 0 1 1.74 1.74c.44.86.44 1.98.44 4.22v7.2c0 2.24 0 3.36-.44 4.22a4 4 0 0 1-1.74 1.74c-.86.44-1.98.44-4.22.44H6.4c-2.24 0-3.36 0-4.22-.44a4 4 0 0 1-1.74-1.74C0 16.96 0 15.84 0 13.6V6.4c0-2.24 0-3.36.44-4.22A4 4 0 0 1 2.18.44C3.04 0 4.16 0 6.4 0ZM4 10a1 1 0 0 1 1-1h10a1 1 0 1 1 0 2H5a1 1 0 0 1-1-1Z",
        fill: "currentColor"
      }),
      (0, import_jsx_runtime72.jsx)("path", {
        d: "M4 10a1 1 0 0 1 1-1h10a1 1 0 1 1 0 2H5a1 1 0 0 1-1-1Z",
        fill: "#fff"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Checkbox/Checkbox.js
var Checkbox = (_param) => {
  var { style, className, disabled, indeterminate } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "disabled",
    "indeterminate"
  ]);
  return (0, import_jsx_runtime73.jsxs)("label", {
    className: classNames("tgui-abbb25a9ce45033e", disabled && "tgui-6e9776e8c33b2626", className),
    children: [
      (0, import_jsx_runtime73.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        className: "tgui-60cf4cc79ba44c4f",
        disabled
      })),
      (0, import_jsx_runtime73.jsx)(IconCheckbox, {
        className: "tgui-21b20ecaad17ccf9",
        "aria-hidden": true
      }),
      (0, import_jsx_runtime73.jsx)("div", {
        "aria-hidden": true,
        className: "tgui-bca5056bf34297b0",
        children: indeterminate ? (0, import_jsx_runtime73.jsx)(IconCheckboxIndeterminate, {}) : (0, import_jsx_runtime73.jsx)(IconCheckboxChecked, {})
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/ColorInput/ColorInput.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var import_react32 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/FormInput/FormInput.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime());
var import_react31 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/FormInput/components/FormInputTitle.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
var FormInputTitle = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  const platform2 = usePlatform();
  if (platform2 === "ios") {
    return (0, import_jsx_runtime74.jsx)(Caption, _object_spread({
      caps: true
    }, restProps));
  }
  return (0, import_jsx_runtime74.jsx)(Subheadline, _object_spread({
    level: "2",
    weight: "2"
  }, restProps));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/FormInput/FormInput.js
var platformStyles = {
  base: "tgui-8ca550c2fc85eff5",
  ios: "tgui-7707c5d942b7b9af"
};
var formStatusStyles = {
  default: "tgui-7584398855f80ae6",
  error: "tgui-41b168516bddcf4b",
  focused: "tgui-89277928456f0e30"
};
var FormInput = (0, import_react31.forwardRef)((_param, ref) => {
  var { status, header, before, after, disabled, children, className, onFocus: onFocusProp, onBlur: onBlurProp } = _param, restProps = _object_without_properties(_param, [
    "status",
    "header",
    "before",
    "after",
    "disabled",
    "children",
    "className",
    "onFocus",
    "onBlur"
  ]);
  const platform2 = usePlatform();
  const [isFocused, setIsFocused] = (0, import_react31.useState)(false);
  const formStatus = status || (isFocused ? "focused" : "default");
  const onFocus = callMultiple(onFocusProp, () => {
    if (disabled) {
      return;
    }
    setIsFocused(true);
  });
  const onBlur = callMultiple(onBlurProp, () => setIsFocused(false));
  return (0, import_jsx_runtime75.jsxs)("div", {
    ref,
    className: classNames("tgui-92da7016c7125c02", platformStyles[platform2], formStatusStyles[formStatus], disabled && "tgui-4a83fef1f04acb0e"),
    "aria-disabled": disabled,
    children: [
      (0, import_jsx_runtime75.jsxs)("label", _object_spread_props(_object_spread({
        "aria-disabled": disabled,
        className: classNames("tgui-0f5050defacbf813", className),
        onFocus,
        onBlur
      }, restProps), {
        children: [
          hasReactNode(before) && (0, import_jsx_runtime75.jsx)("div", {
            className: "tgui-8f04eff653cfa5e5",
            children: before
          }),
          children,
          hasReactNode(after) && (0, import_jsx_runtime75.jsx)("div", {
            className: "tgui-16b3783d394bc7db",
            children: after
          })
        ]
      })),
      hasReactNode(header) && platform2 === "base" && (0, import_jsx_runtime75.jsx)(FormInputTitle, {
        className: "tgui-9f9a52f695b85cc9",
        children: header
      })
    ]
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/ColorInput/ColorInput.js
var ColorInput = (_param) => {
  var { header, before, status, value: valueProp, defaultValue, className, onChange: onChangeProp } = _param, restProps = _object_without_properties(_param, [
    "header",
    "before",
    "status",
    "value",
    "defaultValue",
    "className",
    "onChange"
  ]);
  const platform2 = usePlatform();
  const [value, setValue] = (0, import_react32.useState)(valueProp || defaultValue || "#EFEFF4");
  (0, import_react32.useEffect)(() => {
    if (!valueProp) {
      return;
    }
    setValue(valueProp);
  }, [
    valueProp
  ]);
  const onChange = (e) => {
    setValue(e.target.value);
  };
  const TypographyComponent = platform2 === "ios" ? Text : Subheadline;
  return (0, import_jsx_runtime76.jsx)(FormInput, {
    header,
    before,
    after: (0, import_jsx_runtime76.jsxs)("div", {
      className: "tgui-f3ab78c8048cb9dc",
      children: [
        (0, import_jsx_runtime76.jsx)(VisuallyHidden, _object_spread({
          Component: "input",
          type: "color",
          value,
          onChange: callMultiple(onChange, onChangeProp)
        }, restProps)),
        (0, import_jsx_runtime76.jsx)("div", {
          className: "tgui-93beab8699996b1e",
          style: {
            backgroundColor: String(value)
          }
        })
      ]
    }),
    status,
    className: classNames("tgui-a03137b1ed760aaf", platform2 === "ios" && "tgui-ca1c0e2d013ae260", className),
    children: (0, import_jsx_runtime76.jsx)(TypographyComponent, {
      caps: true,
      className: "tgui-21dba5277ef0ddd7",
      children: value
    })
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/FileInput/FileInput.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());
var import_react33 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/icons/28/attach.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime());
var Icon28Attach = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime77.jsx)("svg", _object_spread_props(_object_spread({
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime77.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M20.286 6.445c-2.342-2.307-6.19-2.307-8.53 0l-5.353 5.272a.99.99 0 0 1-1.388-1.41l5.352-5.272c3.112-3.065 8.196-3.065 11.307 0a7.598 7.598 0 0 1 0 10.885l-7.347 7.238c-2.355 2.32-6.198 2.32-8.553 0a5.762 5.762 0 0 1 0-8.253l7.381-7.27c1.585-1.56 4.141-1.632 5.814-.167a4.06 4.06 0 0 1 .082 6.068l-6.158 5.688a.99.99 0 0 1-1.343-1.454l6.16-5.687c.93-.859.91-2.29-.044-3.127a2.315 2.315 0 0 0-3.122.088l-7.381 7.27a3.784 3.784 0 0 0 0 5.435c1.584 1.56 4.191 1.56 5.775 0l7.348-7.238a5.62 5.62 0 0 0 0-8.066Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/FileInput/FileInput.js
var FileInput = (0, import_react33.forwardRef)((_param, ref) => {
  var { label = "Attach file", className, children } = _param, restProps = _object_without_properties(_param, [
    "label",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime78.jsxs)("div", {
    ref,
    className,
    children: [
      children,
      (0, import_jsx_runtime78.jsxs)(ButtonCell, {
        Component: "label",
        before: (0, import_jsx_runtime78.jsx)(Icon28Attach, {}),
        children: [
          (0, import_jsx_runtime78.jsx)(VisuallyHidden, {
            children: (0, import_jsx_runtime78.jsx)("input", _object_spread({
              type: "file",
              placeholder: label
            }, restProps))
          }),
          label
        ]
      })
    ]
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Input/Input.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());
var Input = (_param) => {
  var { type = "text", header, before, after, status, className, disabled } = _param, restProps = _object_without_properties(_param, [
    "type",
    "header",
    "before",
    "after",
    "status",
    "className",
    "disabled"
  ]);
  const platform2 = usePlatform();
  const TypographyComponent = platform2 === "ios" ? Text : Subheadline;
  return (0, import_jsx_runtime79.jsx)(FormInput, {
    header,
    before,
    after,
    status,
    disabled,
    className: classNames("tgui-d9de1f32aee12a15", platform2 === "ios" && "tgui-9b2ad13855aef059", className),
    children: (0, import_jsx_runtime79.jsx)(TypographyComponent, _object_spread({
      Component: "input",
      className: "tgui-c4863cd4c893a047",
      type,
      disabled
    }, restProps))
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/Multiselect.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());
var import_react45 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/accessibility.js
var Keys = {
  ENTER: "Enter",
  SPACE: "Space",
  TAB: "Tab",
  ESCAPE: "Escape",
  HOME: "Home",
  END: "End",
  BACKSPACE: "Backspace",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var getHorizontalSideByKey = (keys) => {
  switch (keys) {
    case Keys.ARROW_UP:
    case Keys.ARROW_LEFT:
      return "left";
    case Keys.ARROW_DOWN:
    case Keys.ARROW_RIGHT:
      return "right";
    default:
      return void 0;
  }
};

// node_modules/@telegram-apps/telegram-ui/dist/helpers/react/refs.js
var setRef = (element1, ref) => {
  if (ref) {
    if (typeof ref === "function") {
      ref(element1);
    } else {
      ref.current = element1;
    }
  }
};
var multipleRef = (...refs) => {
  let current = null;
  return {
    get current() {
      return current;
    },
    set current(element) {
      current = element;
      refs.forEach((ref) => ref && setRef(element, ref));
    }
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useGlobalClicks.js
var useGlobalClicks = (callback, ...refs) => {
  useEnhancedEffect(() => {
    const hasNotNullRefs = refs.some((ref) => ref && ref.current !== null);
    if (!document || !hasNotNullRefs) {
      return () => {
      };
    }
    const handleClick = (event) => {
      const targetEl = event.target;
      const isClickInsideGivenRefs = isElement(targetEl) && refs.some((ref) => ref && ref.current && ref.current.contains(targetEl));
      !isClickInsideGivenRefs && callback(event);
    };
    document.addEventListener("click", handleClick, {
      passive: true,
      capture: true
    });
    return () => document.removeEventListener("click", handleClick, true);
  }, [
    document,
    callback,
    ...refs
  ]);
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/20/chevron_down.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());
var Icon20ChevronDown = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime80.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime80.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.29289 6.29289c.39053-.39052 1.02369-.39052 1.41422 0L10 11.5858l5.2929-5.29291c.3905-.39052 1.0237-.39052 1.4142 0 .3905.39053.3905 1.02369 0 1.41422l-6 5.99999c-.3905.3905-1.02368.3905-1.41421 0l-6-5.99999c-.39052-.39053-.39052-1.02369 0-1.41422Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectBase/MultiselectBase.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());
var import_react35 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useExternalRefs.js
var import_react34 = __toESM(require_react());
function useExternRef(...externRefs) {
  const stableRef = (0, import_react34.useRef)(null);
  return (0, import_react34.useMemo)(() => ({
    get current() {
      return stableRef.current;
    },
    set current(el) {
      stableRef.current = el;
      externRefs.forEach((ref) => {
        if (ref) {
          setRef(el, ref);
        }
      });
    }
  }), externRefs);
}

// node_modules/@telegram-apps/telegram-ui/dist/icons/16/cancel.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());
var Icon16Cancel = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime81.jsx)("svg", _object_spread_props(_object_spread({
    width: "16",
    height: "16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime81.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.3 3.3a1 1 0 0 1 1.4 0L8 6.58l3.3-3.3a1 1 0 1 1 1.4 1.42L9.42 8l3.3 3.3a1 1 0 0 1-1.42 1.4L8 9.42l-3.3 3.3a1 1 0 0 1-1.4-1.42L6.58 8l-3.3-3.3a1 1 0 0 1 0-1.4Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectBase/helpers/getValueOptionByHTMLElement.js
var getValueOptionByHTMLElement = (options, el) => {
  const value = el.getAttribute("value");
  return options.find((v) => v.value === value);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectBase/constants.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());
var renderChipDefault = (props) => {
  const rest = _extends({}, _object_destructuring_empty(props));
  return (0, import_jsx_runtime82.jsx)(Chip, _object_spread({
    mode: "mono"
  }, rest));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectBase/MultiselectBase.js
var MultiselectBase = (0, import_react35.forwardRef)((_param, ref) => {
  var {
    inputRef,
    className,
    // Option props
    chipsValue,
    onAddChipOption,
    onRemoveChipOption,
    renderChip = renderChipDefault,
    // Input props
    value,
    placeholder,
    disabled,
    readOnly
  } = _param, restProps = _object_without_properties(_param, [
    "inputRef",
    "className",
    "chipsValue",
    "onAddChipOption",
    "onRemoveChipOption",
    "renderChip",
    "value",
    "placeholder",
    "disabled",
    "readOnly"
  ]);
  const listRef = useExternRef(ref);
  const valueLength = chipsValue.length;
  const withPlaceholder = valueLength === 0;
  const isDisabled = disabled || readOnly;
  const handleKeyDown = (event) => {
    const targetEl = event.target;
    const inputEl = inputRef.current;
    if (event.defaultPrevented || !inputEl || !isHTMLElement(targetEl)) {
      return;
    }
    const lastOptionIndex = valueLength - 1;
    const nextInputValue = inputEl.value;
    const isInputEl = targetEl === inputEl;
    const isInputValueEmpty = nextInputValue === "";
    switch (event.key) {
      case Keys.ENTER: {
        if (isInputEl && !isInputValueEmpty) {
          event.preventDefault();
          onAddChipOption(nextInputValue);
        }
        break;
      }
      case Keys.BACKSPACE: {
        if (valueLength) {
          const option = isInputEl && isInputValueEmpty ? chipsValue[lastOptionIndex] : getValueOptionByHTMLElement(chipsValue, targetEl);
          if (!option) {
            return;
          }
          event.preventDefault();
          inputRef.current.focus();
          onRemoveChipOption(option);
        }
        break;
      }
      case Keys.ARROW_UP:
      case Keys.ARROW_LEFT:
      case Keys.ARROW_DOWN:
      case Keys.ARROW_RIGHT: {
        if (!valueLength || !listRef.current) {
          break;
        }
        const isSelectionOnFirstLetter = inputEl.selectionStart === 0;
        const isRightSelection = event.key === Keys.ARROW_RIGHT && isSelectionOnFirstLetter;
        if (!isInputValueEmpty && !isSelectionOnFirstLetter || isRightSelection) {
          break;
        }
        event.preventDefault();
        let foundEl = null;
        const horizontalSide = getHorizontalSideByKey(event.key);
        if (isInputEl && (event.key === Keys.ARROW_UP || event.key === Keys.ARROW_LEFT)) {
          foundEl = getHTMLElementByChildren(listRef.current.children, lastOptionIndex);
        } else if (horizontalSide) {
          foundEl = getHTMLElementSiblingByDirection(targetEl, horizontalSide);
        }
        foundEl && foundEl.focus();
        break;
      }
      default:
        break;
    }
  };
  const handleChipRemove = (event, optionToRemove) => {
    event.preventDefault();
    event.stopPropagation();
    onRemoveChipOption(optionToRemove);
  };
  const handleClick = () => {
    const isFocused = document.activeElement === inputRef.current;
    if (!isFocused && inputRef.current) {
      inputRef.current.focus();
    }
  };
  return (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    (0, import_jsx_runtime83.jsxs)("div", {
      ref: listRef,
      className: classNames("tgui-c56e136f855e5144", withPlaceholder && "tgui-ac1d436c45aafe04", className),
      onClick: isDisabled ? void 0 : handleClick,
      role: "listbox",
      "aria-orientation": "horizontal",
      "aria-disabled": disabled,
      "aria-readonly": readOnly,
      onKeyDown: isDisabled ? void 0 : handleKeyDown,
      children: [
        chipsValue.map((option, index2) => (0, import_jsx_runtime83.jsx)(import_react35.Fragment, {
          children: renderChip({
            children: option.label,
            className: "tgui-991d85450550abb9",
            value: option.value,
            tabIndex: -1,
            after: (0, import_jsx_runtime83.jsx)(Tappable, {
              Component: "div",
              interactiveAnimation: "opacity",
              onClick: (event) => handleChipRemove(event, option),
              className: "tgui-0b4134fd8d5c05ac",
              children: (0, import_jsx_runtime83.jsx)(Icon16Cancel, {})
            }),
            role: "option",
            "aria-selected": true,
            "aria-posinset": index2 + 1,
            "aria-setsize": valueLength
          })
        }, `${typeof option.value}-${option.label}`)),
        (0, import_jsx_runtime83.jsx)(Subheadline, _object_spread_props(_object_spread({
          ref: inputRef,
          "aria-autocomplete": "list",
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          spellCheck: false
        }, restProps), {
          Component: "input",
          type: "text",
          className: "tgui-41e02fd2529dfbd2",
          disabled,
          readOnly,
          placeholder: withPlaceholder ? placeholder : void 0
        }))
      ]
    })
  );
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectDropdown/MultiselectDropdown.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());
var import_react40 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/Popper.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());
var import_react39 = __toESM(require_react());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical2 = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical2 = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical2 ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical2 ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport2 = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport2) {
    width = visualViewport2.width;
    height = visualViewport2.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport2.offsetLeft;
      y = visualViewport2.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var autoPlacement2 = autoPlacement;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React2 = __toESM(require_react(), 1);
var import_react36 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react36.useLayoutEffect : import_react36.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React2.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React2.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React2.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var autoPlacement3 = (options, deps) => ({
  ...autoPlacement2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/components/FloatingArrow/FloatingArrow.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());
var import_react37 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/components/FloatingArrow/helpers/getArrowPositionData.js
var getArrowPositionData = (placement, coords = {
  x: 0,
  y: 0
}, offset4 = 0, isStaticOffset = false) => {
  const withOffset = (isVerticalPlacement) => {
    const parsedCoords = {
      x: coords.x || 0,
      y: coords.y || 0
    };
    return isStaticOffset ? offset4 : parsedCoords[isVerticalPlacement ? "y" : "x"] + offset4;
  };
  if (placement.startsWith("top")) {
    return [
      "bottom",
      {
        top: "100%",
        left: withOffset(false)
      }
    ];
  }
  if (placement.startsWith("right")) {
    return [
      "left",
      {
        top: withOffset(true),
        left: 0
      }
    ];
  }
  if (placement.startsWith("bottom")) {
    return [
      void 0,
      {
        bottom: "100%",
        left: withOffset(false)
      }
    ];
  }
  return [
    "right",
    {
      top: withOffset(true),
      right: 0
    }
  ];
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/components/FloatingArrow/icons/arrow.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());
var DEFAULT_ARROW_WIDTH = 22;
var DEFAULT_ARROW_HEIGHT = 6;
var DEFAULT_ARROW_PADDING = 12;
var PLATFORM_HEIGHT = 1;
var ARROW_HEIGHT_WITH_WHITE_SPACE = DEFAULT_ARROW_HEIGHT + PLATFORM_HEIGHT;
var DefaultIcon = (props) => (0, import_jsx_runtime84.jsx)("svg", _object_spread_props(_object_spread({
  width: DEFAULT_ARROW_WIDTH,
  height: ARROW_HEIGHT_WITH_WHITE_SPACE,
  viewBox: `0 0 ${DEFAULT_ARROW_WIDTH} ${ARROW_HEIGHT_WITH_WHITE_SPACE}`,
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime84.jsx)("path", {
    d: "M10.804 0C6.387 0 6.94 6 .865 6h19.878c-6.074 0-5.521-6-9.939-6Z",
    fill: "currentColor"
  })
}));

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/components/FloatingArrow/FloatingArrow.js
var placementStyles = {
  right: "tgui-6c3deae89ec68e99",
  bottom: "tgui-fed67e27ad8cb75f",
  left: "tgui-b27d1c4f6222569e"
};
var FloatingArrow = (0, import_react37.forwardRef)((_param, ref) => {
  var { style, offset: offset4, isStaticOffset, coords, placement = "bottom", Icon = DefaultIcon, className } = _param, restProps = _object_without_properties(_param, [
    "style",
    "offset",
    "isStaticOffset",
    "coords",
    "placement",
    "Icon",
    "className"
  ]);
  const [arrowPlacement, arrowStyles] = getArrowPositionData(placement, coords, offset4, isStaticOffset);
  return (0, import_jsx_runtime85.jsx)("div", _object_spread_props(_object_spread({
    ref,
    style: _object_spread({}, arrowStyles, style),
    className: classNames("tgui-97a62789a70393d0", arrowPlacement && placementStyles[arrowPlacement], className)
  }, restProps), {
    children: (0, import_jsx_runtime85.jsx)(Icon, {
      className: "tgui-6ae8c47f9448321b"
    })
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/helpers/autoUpdateFloatingElement.js
var defaultOptions = {
  ancestorScroll: true,
  ancestorResize: true,
  elementResize: false,
  animationFrame: false
};
var autoUpdateFloatingElement = (reference, floating, update, options = defaultOptions) => {
  const { elementResize = false } = options, restOptions = _object_without_properties(options, [
    "elementResize"
  ]);
  const autoUpdateLibDisposer = autoUpdate(reference, floating, update, _object_spread_props(_object_spread({}, restOptions), {
    elementResize: false
  }));
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new MutationObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    if (isHTMLElement(reference)) {
      observer.observe(reference, {
        childList: true,
        subtree: true
      });
    }
    observer.observe(floating, {
      childList: true,
      subtree: true
    });
  }
  return () => {
    if (observer !== null) {
      observer.disconnect();
      observer = null;
    }
    autoUpdateLibDisposer();
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/hooks/useFloatingMiddlewares.js
var import_react38 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/hooks/helpers/alignment.js
var isNotAutoPlacement = (placement) => {
  return !placement.startsWith("auto");
};
var getAutoPlacementAlignment = (placement) => {
  const align = placement.replace(/auto-|auto/, "");
  return align === "start" || align === "end" ? align : null;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/hooks/useFloatingMiddlewares.js
var useFloatingMiddlewares = ({ placement = "bottom-start", arrowRef = null, withArrow, arrowHeight, arrowPadding, sameWidth, offsetByMainAxis = 0, offsetByCrossAxis = 0, customMiddlewares }) => {
  return (0, import_react38.useMemo)(() => {
    const isNotAutoPlaced = isNotAutoPlacement(placement);
    const middlewares = [
      offset3({
        crossAxis: offsetByCrossAxis,
        mainAxis: withArrow && arrowHeight ? offsetByMainAxis + arrowHeight : offsetByMainAxis
      })
    ];
    if (isNotAutoPlaced) {
      middlewares.push(flip3({
        fallbackAxisSideDirection: "start"
      }));
    } else {
      middlewares.push(autoPlacement3({
        alignment: getAutoPlacementAlignment(placement)
      }));
    }
    middlewares.push(shift3());
    if (sameWidth) {
      middlewares.push(size3({
        apply({ rects, elements }) {
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }));
    }
    if (customMiddlewares) {
      middlewares.push(...customMiddlewares);
    }
    if (withArrow) {
      middlewares.push(arrow3({
        element: arrowRef,
        padding: arrowPadding
      }));
    }
    return {
      middlewares,
      strictPlacement: isNotAutoPlaced ? placement : void 0
    };
  }, [
    offsetByCrossAxis,
    arrowRef,
    withArrow,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    sameWidth,
    customMiddlewares,
    placement
  ]);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Popper/Popper.js
var Popper = (0, import_react39.forwardRef)((_param, ref) => {
  var {
    // UseFloatingMiddlewaresOptions
    placement = "auto",
    sameWidth,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    withArrow = true,
    customMiddlewares,
    // UseFloatingProps
    autoUpdateOnTargetResize = false,
    // ArrowProps
    arrowProps,
    ArrowIcon = DefaultIcon,
    Component = "div",
    style,
    targetRef,
    className,
    children
  } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "sameWidth",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "withArrow",
    "customMiddlewares",
    "autoUpdateOnTargetResize",
    "arrowProps",
    "ArrowIcon",
    "Component",
    "style",
    "targetRef",
    "className",
    "children"
  ]);
  const [arrowRef, setArrowRef] = (0, import_react39.useState)(null);
  const { strictPlacement, middlewares } = useFloatingMiddlewares({
    placement,
    sameWidth,
    withArrow,
    arrowRef,
    arrowHeight: (arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.height) || DEFAULT_ARROW_HEIGHT,
    arrowPadding: (arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.padding) || DEFAULT_ARROW_PADDING,
    offsetByMainAxis,
    offsetByCrossAxis,
    customMiddlewares
  });
  const { placement: resolvedPlacement, refs, middlewareData, floatingStyles } = useFloating({
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted(...args) {
      return autoUpdateFloatingElement(...args, {
        elementResize: autoUpdateOnTargetResize
      });
    }
  });
  useEnhancedEffect(() => {
    refs.setReference("current" in targetRef ? targetRef.current : targetRef);
  }, [
    refs.setReference,
    targetRef
  ]);
  return (0, import_jsx_runtime86.jsx)(RootRenderer, {
    children: (0, import_jsx_runtime86.jsxs)(Component, _object_spread_props(_object_spread({}, restProps), {
      ref: multipleRef(ref, refs.setFloating),
      style: _object_spread({}, style, floatingStyles),
      className: classNames("tgui-e9c83f4f150e5513", className),
      children: [
        withArrow && (0, import_jsx_runtime86.jsx)(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
          coords: middlewareData.arrow,
          placement: resolvedPlacement,
          ref: setArrowRef,
          Icon: ArrowIcon
        })),
        children
      ]
    }))
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/constants.js
var DEFAULT_SELECTED_BEHAVIOR = "highlight";
var DEFAULT_EMPTY_TEXT = "Nothing found";
var FOCUS_ACTION_NEXT = "next";
var FOCUS_ACTION_PREV = "prev";
var isCreateNewOptionPreset = (option) => {
  return option && "actionText" in option;
};
var isEmptyOptionPreset = (option) => {
  return option && "placeholder" in option;
};
var isServicePreset = (option) => isCreateNewOptionPreset(option) || isEmptyOptionPreset(option);

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectDropdown/constants.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/icons/20/select.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());
var Icon20Select = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime87.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime87.jsx)("path", {
      d: "M2.5 10.821 7 15.75l10.5-11.5",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/20/select_ios.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime());
var Icon20SelectIOS = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime88.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime88.jsx)("path", {
      d: "M8.174 18c-.473 0-.876-.21-1.208-.63l-4.602-5.82a1.727 1.727 0 0 1-.284-.465 1.423 1.423 0 0 1-.08-.474c0-.365.118-.666.355-.903s.536-.356.898-.356c.408 0 .752.18 1.03.539l3.856 5.017 7.525-12.242c.154-.243.313-.414.48-.51.165-.104.372-.156.621-.156.361 0 .657.116.889.347.23.23.346.526.346.884 0 .146-.024.292-.071.438a2.017 2.017 0 0 1-.222.456L9.39 17.335c-.284.443-.69.665-1.217.665Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectDropdown/constants.js
var renderOptionDefault = (props) => {
  const platform2 = usePlatform();
  const SelectedIcon = platform2 === "ios" ? Icon20SelectIOS : Icon20Select;
  return (0, import_jsx_runtime89.jsx)(Cell, _object_spread_props(_object_spread({}, props), {
    after: props.selected ? (0, import_jsx_runtime89.jsx)(SelectedIcon, {
      className: "tgui-e3f4e376df0c272c"
    }) : void 0
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/components/MultiselectDropdown/MultiselectDropdown.js
var MultiselectDropdown = (0, import_react40.forwardRef)(({ dropdownAriaId, options, onMouseLeave, targetRef, addOptionFromInput, setFocusedOptionIndex, renderOption = renderOptionDefault, focusedOption, value, setOptionNode, setOpened, closeDropdownAfterSelect, addOption, focusedOptionIndex, clearInput }, ref) => {
  return (0, import_jsx_runtime90.jsx)(Popper, {
    id: dropdownAriaId,
    ref,
    targetRef,
    onMouseLeave,
    autoUpdateOnTargetResize: true,
    role: "listbox",
    placement: "bottom",
    sameWidth: true,
    className: "tgui-70d34454bcf3c3e4",
    children: options.map((option, index2) => {
      if (isEmptyOptionPreset(option)) {
        return (0, import_jsx_runtime90.jsx)(Cell, {
          readOnly: true,
          className: "tgui-6a25d2bd42bb932c",
          children: option.placeholder
        }, "empty");
      }
      if (isCreateNewOptionPreset(option)) {
        return (0, import_jsx_runtime90.jsx)(Cell, {
          hovered: focusedOptionIndex === index2,
          onMouseDown: addOptionFromInput,
          onMouseEnter: () => setFocusedOptionIndex(index2),
          children: option.actionText
        }, "new-options");
      }
      return (0, import_jsx_runtime90.jsx)(import_react40.Fragment, {
        children: renderOption({
          className: "tgui-15f9ec3c119467a6",
          hovered: focusedOption ? option.value === focusedOption.value : false,
          children: option.label,
          selected: value.findIndex((selectedOption) => selectedOption.value === option.value) !== -1,
          ref: (node) => setOptionNode(index2, node),
          onMouseDown: (event) => {
            if (event.defaultPrevented) {
              return;
            }
            closeDropdownAfterSelect && setOpened(false);
            addOption(option);
            clearInput();
          },
          onMouseEnter: () => setFocusedOptionIndex(index2)
        })
      }, `${typeof option.value}-${option.label}`);
    })
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/useMultiselect.js
var import_react44 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/react/children.js
var import_react41 = __toESM(require_react());
var childToString = (child) => {
  if (typeof child === "undefined" || child === null || typeof child === "boolean") {
    return "";
  }
  if (JSON.stringify(child) === "{}") {
    return "";
  }
  return child.toString();
};
var getTextFromChildren = (children) => {
  if (!(children instanceof Array) && !(0, import_react41.isValidElement)(children)) {
    return childToString(children);
  }
  return import_react41.Children.toArray(children).reduce((text, child) => {
    let newText = "";
    const isValidElementResult = (0, import_react41.isValidElement)(child);
    const hasChildren = isValidElementResult && "children" in child.props;
    if (isValidElementResult && hasChildren) {
      newText = getTextFromChildren(child.props.children);
    } else if (isValidElementResult && !hasChildren) {
      newText = "";
    } else {
      newText = childToString(child);
    }
    return text.concat(newText);
  }, "");
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/helpers/filter/index.js
function defaultFilterFn(...args) {
  const [rawSearchQuery = "", option] = args;
  if ((option === null || option === void 0 ? void 0 : option.label) === void 0) {
    return false;
  }
  const searchQuery = rawSearchQuery.trim().toLocaleLowerCase();
  const label = getTextFromChildren(option.label).toLocaleLowerCase();
  if (label.startsWith(searchQuery)) {
    return true;
  }
  const findAllIncludes = (target = "", search = "") => {
    const includes2 = [];
    let i = target.indexOf(search);
    while (i !== -1) {
      includes2.push(i);
      i = target.indexOf(search, i + 1);
    }
    return includes2;
  };
  const includes = findAllIncludes(label, searchQuery);
  if (includes.length === 0) {
    return false;
  }
  return includes.some((index2) => index2 === 0 || !RegExp("\\p{L}", "u").test(label[index2 - 1]));
}

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/helpers/getNewOptionData.js
var getNewOptionData = (value, label) => ({
  value,
  label
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/helpers/transformOptions.js
var transformOptions = ({ value, inputValue = "", emptyText, creatable = false, filterFn, options: optionsProp, selectedBehavior }) => {
  const filteredOptionsProp = filterFn ? optionsProp.filter((option) => filterFn(inputValue, option)) : optionsProp;
  if (filteredOptionsProp.length === 0) {
    if (inputValue !== "" && typeof creatable === "string") {
      return [
        _object_spread_props(_object_spread({}, getNewOptionData("", "")), {
          actionText: creatable
        })
      ];
    }
    return [
      _object_spread_props(_object_spread({}, getNewOptionData("", "")), {
        placeholder: emptyText
      })
    ];
  }
  if (selectedBehavior === "hide") {
    const selected = value.map((item) => item.value);
    return filteredOptionsProp.filter((item) => {
      return !isServicePreset(item) ? !selected.includes(item.value) : false;
    });
  }
  return filteredOptionsProp;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/useMultiselectInput.js
var import_react43 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useEnsureControl.js
var import_react42 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/fuctions.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useEnsureControl.js
function useCustomEnsuredControl({ value, defaultValue, disabled, onChange: onChangeProp }) {
  const isControlled = value !== void 0;
  const [localValue, setLocalValue] = (0, import_react42.useState)(defaultValue);
  const preservedControlledValueRef = (0, import_react42.useRef)();
  useEnhancedEffect(() => {
    preservedControlledValueRef.current = value;
  });
  const onChange = (0, import_react42.useCallback)((nextValue) => {
    if (disabled) {
      return;
    }
    if (isFunction(nextValue)) {
      if (!isControlled) {
        setLocalValue((prevValue) => {
          const resolvedValue = nextValue(prevValue);
          if (onChangeProp) {
            onChangeProp(resolvedValue);
          }
          return resolvedValue;
        });
      } else if (onChangeProp) {
        const resolvedValue = nextValue(preservedControlledValueRef.current);
        onChangeProp(resolvedValue);
      }
      return;
    }
    onChangeProp && onChangeProp(nextValue);
    !isControlled && setLocalValue(nextValue);
  }, [
    disabled,
    isControlled,
    onChangeProp
  ]);
  return [
    isControlled ? value : localValue,
    onChange
  ];
}

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/helpers/isValueLikeOption.js
var isValueLikeOption = (value) => typeof value === "object" && "value" in value;

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/helpers/simulateReactInput.js
var simulateReactInput = (target, nextValue = "") => {
  try {
    const simulateTarget = target;
    const prevValue = simulateTarget.value;
    simulateTarget.value = nextValue;
    const tracker = simulateTarget._valueTracker;
    tracker === null || tracker === void 0 ? void 0 : tracker.setValue(prevValue);
    const event = new Event("input", {
      bubbles: true
    });
    target.dispatchEvent(event);
  } catch (error) {
    if (true) {
      throw error;
    }
  }
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/useMultiselectInput.js
var useMultiselectInput = ({ disabled, value: valueProp, onChange, defaultValue = [], inputValue: inputValueProp = "", onInputChange }) => {
  const [value, setValue] = useCustomEnsuredControl({
    value: valueProp,
    disabled,
    defaultValue,
    onChange
  });
  const inputRef = (0, import_react43.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react43.useState)(inputValueProp);
  const toggleOption = (0, import_react43.useCallback)((nextValueProp, isNewValue) => {
    let valueForChange = valueProp;
    setValue((prevValue) => {
      const isLikeOption = isValueLikeOption(nextValueProp);
      const resolvedOption = isLikeOption ? getNewOptionData(nextValueProp.value, nextValueProp.label) : getNewOptionData(nextValueProp, typeof nextValueProp === "string" ? nextValueProp : "");
      const nextValue = prevValue.filter((option) => resolvedOption.value !== option.value);
      if (isNewValue) {
        nextValue.push(isLikeOption ? _object_spread({}, nextValueProp, resolvedOption) : resolvedOption);
      }
      valueForChange = nextValue;
      return nextValue;
    });
    onChange === null || onChange === void 0 ? void 0 : onChange(valueForChange);
  }, [
    setValue
  ]);
  const clearInput = (0, import_react43.useCallback)(() => {
    simulateReactInput(inputRef.current, "");
  }, [
    inputRef
  ]);
  const addOption = (0, import_react43.useCallback)((newValue) => toggleOption(newValue, true), [
    toggleOption
  ]);
  const removeOption = (0, import_react43.useCallback)((newValue) => {
    toggleOption(newValue, false);
  }, [
    toggleOption
  ]);
  const addOptionFromInput = (0, import_react43.useCallback)((inputValueToAdd) => {
    const label = inputValueToAdd.trim();
    if (!label) {
      return;
    }
    addOption(label);
    clearInput();
  }, [
    addOption,
    clearInput
  ]);
  const inputChange = (0, import_react43.useCallback)((event) => {
    setInputValue(event.currentTarget.value);
    onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(event);
  }, [
    onInputChange
  ]);
  return {
    value,
    addOption,
    addOptionFromInput,
    removeOption,
    inputRef,
    inputValue,
    onInputChange: inputChange,
    clearInput
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/hooks/useMultiselect.js
var useMultiselect = ({
  // Common props
  disabled,
  // Options props
  value: valueProp,
  defaultValue,
  onChange,
  // Input props
  inputValue: inputValueProp = "",
  onInputChange: onInputChangeProp,
  // Dropdown props
  creatable = false,
  emptyText = DEFAULT_EMPTY_TEXT,
  filterFn = defaultFilterFn,
  selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
  options: optionsProp = []
}) => {
  const _useMultiselectInput = useMultiselectInput({
    // Option props
    value: valueProp,
    defaultValue,
    onChange,
    // Input Props
    inputValue: inputValueProp,
    onInputChange: onInputChangeProp,
    // Other Props
    disabled
  }), { value, inputValue, onInputChange } = _useMultiselectInput, restMultiselectProps = _object_without_properties(_useMultiselectInput, [
    "value",
    "inputValue",
    "onInputChange"
  ]);
  const [opened, setOpened] = (0, import_react44.useState)(false);
  const [options, setOptions] = (0, import_react44.useState)(() => opened ? transformOptions({
    value,
    inputValue,
    emptyText,
    creatable,
    filterFn,
    options: optionsProp,
    selectedBehavior
  }) : []);
  const [focusedOptionIndex, setFocusedOptionIndex] = (0, import_react44.useState)(0);
  const [focusedOption, setFocusedOption] = (0, import_react44.useState)(null);
  const handleInputChange = (0, import_react44.useCallback)((event) => {
    onInputChange(event);
    if (!opened) {
      return;
    }
    setOpened(true);
    setFocusedOptionIndex(0);
  }, [
    onInputChange,
    opened
  ]);
  useEnhancedEffect(() => {
    if (!opened) {
      return;
    }
    setOptions((prevOptions) => {
      const nextOptions = transformOptions({
        value,
        inputValue,
        emptyText,
        creatable,
        filterFn,
        options: optionsProp,
        selectedBehavior
      });
      if (isEqual(prevOptions, nextOptions)) {
        return prevOptions;
      }
      return nextOptions;
    });
  }, [
    opened,
    value,
    inputValue,
    optionsProp,
    creatable,
    selectedBehavior,
    filterFn
  ]);
  return _object_spread_props(_object_spread({}, restMultiselectProps), {
    // Options props
    value,
    // Input props
    inputValue,
    onInputChange: handleInputChange,
    // States for dropdown
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselect/Multiselect.js
var Multiselect = (0, import_react45.forwardRef)((_param, ref) => {
  var {
    // FormInput options
    header,
    before,
    status,
    className,
    children,
    disabled,
    // CustomSelectDropdownProps
    options: optionsProp,
    closeDropdownAfterSelect = false,
    selectedBehavior,
    emptyText,
    creatable = false,
    filterFn,
    // MultiselectInputProps
    value: valueProp = [],
    defaultValue,
    inputValue: inputValueProp,
    renderChip,
    renderOption,
    onInputChange: onInputChangeProp,
    onChange,
    onFocus,
    onBlur,
    onKeyDown
  } = _param, restProps = _object_without_properties(_param, [
    "header",
    "before",
    "status",
    "className",
    "children",
    "disabled",
    "options",
    "closeDropdownAfterSelect",
    "selectedBehavior",
    "emptyText",
    "creatable",
    "filterFn",
    "value",
    "defaultValue",
    "inputValue",
    "renderChip",
    "renderOption",
    "onInputChange",
    "onChange",
    "onFocus",
    "onBlur",
    "onKeyDown"
  ]);
  const {
    // Option props
    value,
    addOptionFromInput,
    addOption,
    removeOption,
    // Input props
    inputRef,
    inputValue,
    clearInput,
    onInputChange,
    // Dropdown props
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  } = useMultiselect({
    // Option props
    value: valueProp,
    defaultValue,
    onChange,
    // Input props
    inputValue: inputValueProp,
    onInputChange: onInputChangeProp,
    // Dropdown props
    options: optionsProp,
    emptyText,
    creatable,
    filterFn,
    selectedBehavior,
    // Other props
    disabled
  });
  const containerRef = (0, import_react45.useRef)(null);
  const rootRef = (0, import_react45.useRef)(null);
  const dropdownAriaId = (0, import_react45.useId)();
  const dropdownScrollBoxRef = (0, import_react45.useRef)(null);
  const handleFocus = () => {
    setOpened(true);
    setFocusedOptionIndex(null);
  };
  const handleBlur = (event) => {
    if (!event.defaultPrevented && !creatable) {
      event.preventDefault();
    }
  };
  const optionsNodes = (0, import_react45.useRef)([]).current;
  const scrollToElement = (index2, center = false) => {
    const dropdown = dropdownScrollBoxRef.current;
    const item = optionsNodes[index2];
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const { scrollTop } = dropdown;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  };
  const focusOptionByIndex = (index2, oldIndex) => {
    let focusedIndex = index2;
    const { length } = options;
    if (index2 < 0) {
      focusedIndex = length - 1;
    } else if (index2 >= length) {
      focusedIndex = 0;
    }
    if (focusedIndex === oldIndex) {
      return;
    }
    scrollToElement(focusedIndex);
    setFocusedOptionIndex(focusedIndex);
  };
  const focusOption = (nextIndex, type) => {
    let index2 = nextIndex === null ? -1 : nextIndex;
    if (type === FOCUS_ACTION_NEXT) {
      index2 += 1;
    }
    if (type === FOCUS_ACTION_PREV) {
      index2 -= 1;
    }
    focusOptionByIndex(index2, focusedOptionIndex);
  };
  const handleKeyDown = (event) => {
    if (event.defaultPrevented) {
      return;
    }
    switch (event.key) {
      case Keys.ARROW_UP:
      case Keys.ARROW_DOWN:
        event.preventDefault();
        if (opened) {
          focusOption(focusedOptionIndex, event.key === Keys.ARROW_UP ? FOCUS_ACTION_PREV : FOCUS_ACTION_NEXT);
          return;
        }
        setOpened(true);
        setFocusedOptionIndex(0);
        break;
      case Keys.ENTER: {
        if (!opened) {
          break;
        }
        if (!creatable) {
          event.preventDefault();
        }
        if (focusedOptionIndex === null) {
          break;
        }
        const foundOption = options[focusedOptionIndex];
        if (!foundOption || isServicePreset(foundOption)) {
          break;
        }
        event.preventDefault();
        addOption(foundOption);
        setFocusedOptionIndex(null);
        clearInput();
        closeDropdownAfterSelect && setOpened(false);
        break;
      }
      case Keys.ESCAPE:
      case Keys.TAB:
        opened && setOpened(false);
        break;
      default:
        break;
    }
  };
  (0, import_react45.useEffect)(() => {
    if (focusedOptionIndex === null) {
      setFocusedOption(null);
      return;
    }
    const foundFocusedOptionIndex = options[focusedOptionIndex];
    if (foundFocusedOptionIndex && !isServicePreset(foundFocusedOptionIndex)) {
      setFocusedOption(foundFocusedOptionIndex);
    }
  }, [
    options,
    focusedOptionIndex,
    setFocusedOption
  ]);
  const onDropdownMouseLeave = (0, import_react45.useCallback)(() => {
    setFocusedOptionIndex(null);
  }, [
    setFocusedOptionIndex
  ]);
  const toggleOpened = () => {
    setOpened((prevOpened) => !prevOpened);
  };
  const handleClickOutside = (0, import_react45.useCallback)(() => {
    setOpened(false);
  }, [
    setOpened
  ]);
  const setOptionNode = (index2, node) => {
    optionsNodes[index2] = node;
  };
  useGlobalClicks(handleClickOutside, opened ? rootRef : null, opened ? dropdownScrollBoxRef : null);
  const controlledStatus = status || (opened ? "focused" : "default");
  return (0, import_jsx_runtime91.jsxs)(FormInput, {
    ref: multipleRef(ref, containerRef),
    header,
    before,
    status: controlledStatus,
    disabled,
    className: classNames("tgui-6cca8a28a056cc34", className),
    children: [
      (0, import_jsx_runtime91.jsx)(MultiselectBase, _object_spread_props(_object_spread({}, restProps), {
        // FormFieldProps
        ref: rootRef,
        className: "tgui-1ed7193796bd9fff",
        // Option props
        onAddChipOption: addOptionFromInput,
        onRemoveChipOption: removeOption,
        renderChip,
        chipsValue: value,
        // Input props
        value: inputValue,
        inputRef,
        onChange: onInputChange,
        onFocus: callMultiple(handleFocus, onFocus),
        onBlur: callMultiple(handleBlur, onBlur),
        onKeyDown: callMultiple(handleKeyDown, onKeyDown),
        // a11y props
        role: "combobox",
        "aria-expanded": opened,
        "aria-controls": dropdownAriaId,
        "aria-haspopup": "listbox"
      })),
      (0, import_jsx_runtime91.jsx)(Icon20ChevronDown, {
        "aria-hidden": true,
        onClick: toggleOpened,
        className: "tgui-e9b05eb8feaa0359"
      }),
      opened && (0, import_jsx_runtime91.jsx)(MultiselectDropdown, {
        ref: dropdownScrollBoxRef,
        dropdownAriaId,
        options,
        onMouseLeave: onDropdownMouseLeave,
        targetRef: rootRef,
        addOptionFromInput: () => addOptionFromInput(inputValue),
        setFocusedOptionIndex,
        renderOption,
        focusedOption,
        value,
        setOptionNode,
        setOpened,
        closeDropdownAfterSelect,
        addOption,
        clearInput,
        focusedOptionIndex
      })
    ]
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/Multiselectable.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/icons/multiselectable.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime());
var IconMultiselectable = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime92.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime92.jsx)("circle", {
      cx: "10",
      cy: "10",
      r: "9",
      stroke: "currentColor",
      strokeWidth: "2"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/icons/multiselectable_checked.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime());
var IconMultiselectableChecked = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime93.jsxs)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime93.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z",
        fill: "currentColor"
      }),
      (0, import_jsx_runtime93.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M15.375 6.56a1 1 0 0 1-.036 1.415l-6.31 6a1 1 0 0 1-1.416-.037l-2.84-3a1 1 0 0 1 1.453-1.375l2.15 2.272 5.585-5.31a1 1 0 0 1 1.414.036Z",
        fill: "#fff"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/icons/multiselectable_ios.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime());
var IconMultiselectableIOS = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime94.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime94.jsx)("circle", {
      cx: "12",
      cy: "12",
      r: "11",
      stroke: "currentColor",
      strokeWidth: "2"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/icons/multiselectable_ios_checked.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime());
var IconMultiselectableIOSChecked = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime95.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime95.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12 24a12 12 0 1 0 0-24 12 12 0 0 0 0 24Zm4.78-17.1a1 1 0 0 1 .32 1.38l-5.63 9a1 1 0 0 1-1.62.1l-3.37-4.12a1 1 0 1 1 1.54-1.27l2.5 3.05 4.88-7.82a1 1 0 0 1 1.38-.32Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Multiselectable/Multiselectable.js
var Multiselectable = (_param) => {
  var { style, className, disabled } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "disabled"
  ]);
  const platform2 = usePlatform();
  const UnCheckedIcon = platform2 === "ios" ? IconMultiselectableIOS : IconMultiselectable;
  const CheckedIcon = platform2 === "ios" ? IconMultiselectableIOSChecked : IconMultiselectableChecked;
  return (0, import_jsx_runtime96.jsxs)("label", {
    className: classNames("tgui-9bfdebc3fdae031b", disabled && "tgui-55c1caaee1c1e33e", className),
    children: [
      (0, import_jsx_runtime96.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        className: "tgui-7cd9bbef46d9194c",
        disabled
      })),
      (0, import_jsx_runtime96.jsx)(UnCheckedIcon, {
        className: "tgui-18734a5360b84fba",
        "aria-hidden": true
      }),
      (0, import_jsx_runtime96.jsx)(CheckedIcon, {
        className: "tgui-1ec4b447aa5cf66a",
        "aria-hidden": true
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/PinInput/PinInput.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime());
var import_react48 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/chunk.js
var createChunks = (array, chunkSize) => {
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/36/backspace.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime());
var Icon36Backspace = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime97.jsx)("svg", _object_spread_props(_object_spread({
    width: "36",
    height: "36",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime97.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M15.886 6.5h8.855c.805 0 1.47 0 2.01.044.563.046 1.08.145 1.564.392a4 4 0 0 1 1.749 1.748c.247.485.345 1.002.391 1.564.045.541.045 1.206.045 2.01v11.483c0 .805 0 1.47-.045 2.01-.046.563-.144 1.08-.391 1.565a4 4 0 0 1-1.748 1.748c-.486.247-1.002.346-1.565.392-.54.044-1.205.044-2.01.044h-8.855c-.635 0-1.115 0-1.578-.11a4.001 4.001 0 0 1-1.156-.48c-.405-.248-.745-.587-1.193-1.037l-.072-.072-5.73-5.729c-.569-.57-1.039-1.039-1.39-1.453-.365-.43-.66-.865-.829-1.383a4 4 0 0 1 0-2.472c.168-.518.464-.953.829-1.383.351-.414.821-.884 1.39-1.453l5.73-5.73.072-.071c.448-.45.787-.789 1.193-1.038a4 4 0 0 1 1.156-.479c.463-.11.943-.11 1.578-.11Zm.102 2c-.782 0-1.01.006-1.213.055-.204.05-.399.13-.578.24-.178.109-.344.265-.896.818l-5.7 5.7c-.606.606-1.017 1.018-1.31 1.362-.284.335-.397.54-.45.707a2 2 0 0 0 0 1.236c.053.167.166.371.45.707.293.344.704.756 1.31 1.362l5.7 5.7c.552.552.718.709.896.818.18.11.374.19.578.24.204.049.431.055 1.213.055H24.7c.856 0 1.438 0 1.889-.038.438-.035.662-.1.819-.18a2 2 0 0 0 .874-.874c.08-.157.144-.38.18-.82.037-.45.038-1.032.038-1.888V12.3c0-.857-.001-1.439-.038-1.889-.036-.438-.1-.663-.18-.819a2 2 0 0 0-.875-.874c-.156-.08-.38-.145-.819-.18-.45-.037-1.032-.038-1.889-.038h-8.711Zm-1.196 4.793a1 1 0 0 1 1.415 0l3.293 3.293 3.292-3.293a1 1 0 0 1 1.415 1.414L20.914 18l3.293 3.293a1 1 0 0 1-1.415 1.414L19.5 19.414l-3.292 3.293a1 1 0 1 1-1.415-1.414L18.085 18l-3.293-3.293a1 1 0 0 1 0-1.414Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/PinInput/components/PinInputButton/PinInputButton.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime());
var ButtonTypography2 = (props) => {
  const platform2 = usePlatform();
  if (platform2 === "ios") {
    return (0, import_jsx_runtime98.jsx)(LargeTitle, _object_spread({}, props));
  }
  return (0, import_jsx_runtime98.jsx)(Title, _object_spread({}, props));
};
var PinInputButton = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime98.jsx)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    className: classNames("tgui-6eaa561b38208c72", platform2 === "ios" && "tgui-3bea52c968cee224")
  }, restProps), {
    children: (0, import_jsx_runtime98.jsx)(ButtonTypography2, {
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/PinInput/components/PinInputCell/PinInputCell.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime());
var import_react46 = __toESM(require_react());
var PinInputCell = (0, import_react46.forwardRef)((_param, ref) => {
  var { isTyped } = _param, restProps = _object_without_properties(_param, [
    "isTyped"
  ]);
  const platform2 = usePlatform();
  const isIOS2 = platform2 === "ios";
  return (0, import_jsx_runtime99.jsxs)("label", {
    ref,
    className: classNames("tgui-bad1e0d3a612c110", isIOS2 && "tgui-b9a1527d00258387", isTyped && "tgui-1d6fb1351888c5e0"),
    children: [
      (0, import_jsx_runtime99.jsx)(VisuallyHidden, _object_spread({
        Component: "input",
        type: "number",
        maxLength: 1,
        className: "tgui-0bd147a2a35a8dd1"
      }, restProps)),
      isTyped && !isIOS2 && (0, import_jsx_runtime99.jsx)("div", {
        className: "tgui-9fa4f4531187df59"
      })
    ]
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/PinInput/hooks/usePinInput.js
var import_react47 = __toESM(require_react());
var AVAILABLE_PINS = [
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  0,
  Keys.BACKSPACE
];
var usePinInput = ({ pinCount, value: valueProp = [], onChange }) => {
  const inputRefs = (0, import_react47.useRef)([]).current;
  const [value, setValue] = useCustomEnsuredControl({
    defaultValue: valueProp,
    onChange
  });
  const focusByIndex = (index2) => {
    requestAnimationFrame(() => {
      var _inputRefs_index;
      return (_inputRefs_index = inputRefs[index2]) === null || _inputRefs_index === void 0 ? void 0 : _inputRefs_index.focus();
    });
  };
  const setValueByIndex = (index2, newValue) => {
    setValue((prev) => {
      const nextValue = [
        ...prev
      ];
      nextValue[index2] = newValue;
      return nextValue;
    });
  };
  const removeLastValue = (currentIndex) => {
    setValue((prev) => prev.slice(0, -1));
    focusByIndex(currentIndex - 1);
  };
  const handleClickValue = (0, import_react47.useCallback)((enteredValue) => {
    const lastIndex = clamp(value.length, 0, pinCount - 1);
    setValueByIndex(lastIndex, enteredValue);
    focusByIndex(lastIndex + 1);
  }, [
    value,
    pinCount
  ]);
  const handleClickBackspace = (0, import_react47.useCallback)(() => {
    removeLastValue(value.length - 1);
  }, [
    value
  ]);
  const handleButton = (0, import_react47.useCallback)((index2, button) => {
    if (AVAILABLE_PINS.includes(Number(button))) {
      setValueByIndex(index2, Number(button));
      focusByIndex(index2 + 1);
    }
    switch (button) {
      case Keys.BACKSPACE:
        removeLastValue(index2);
        break;
      case Keys.ARROW_LEFT:
        focusByIndex(index2 - 1);
        break;
      case Keys.ARROW_RIGHT:
        focusByIndex(index2 + 1);
        break;
      default:
        break;
    }
  }, []);
  const setInputRefByIndex = (0, import_react47.useCallback)((index2, ref) => {
    if (!ref) {
      return;
    }
    inputRefs[index2] = ref;
  }, []);
  return {
    value,
    setInputRefByIndex,
    handleClickValue,
    handleClickBackspace,
    handleButton
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/PinInput/PinInput.js
var PIN_MIN_COUNT = 2;
var PinInput = (0, import_react48.forwardRef)((_param, ref) => {
  var { label = "Enter your pin", pinCount = 4, className, value: valueProp = [], onChange } = _param, restProps = _object_without_properties(_param, [
    "label",
    "pinCount",
    "className",
    "value",
    "onChange"
  ]);
  const platform2 = usePlatform();
  const normalizedPinCount = Math.max(PIN_MIN_COUNT, pinCount);
  const { handleClickValue, handleClickBackspace, setInputRefByIndex, value, handleButton } = usePinInput({
    value: valueProp,
    onChange,
    pinCount: normalizedPinCount
  });
  return (0, import_jsx_runtime100.jsx)(RootRenderer, {
    children: (0, import_jsx_runtime100.jsxs)("section", _object_spread_props(_object_spread({
      ref,
      className: classNames("tgui-a641ca1e63331268", platform2 === "ios" && "tgui-bf64531d065e1bd9", className)
    }, restProps), {
      children: [
        (0, import_jsx_runtime100.jsxs)("header", {
          className: "tgui-a40b67b8ec9e3a49",
          children: [
            (0, import_jsx_runtime100.jsx)(Headline, {
              className: "tgui-7df9ee9d6d6586de",
              weight: "2",
              children: label
            }),
            (0, import_jsx_runtime100.jsx)("div", {
              className: "tgui-36c453f0a9d51371",
              children: Array.from({
                length: normalizedPinCount
              }).map((_, index2) => (0, import_jsx_runtime100.jsx)(PinInputCell, {
                ref: (labelRef) => setInputRefByIndex(index2, labelRef),
                isTyped: index2 < value.length,
                value: value[index2] || "",
                onKeyDown: (event) => handleButton(index2, event.key),
                autoFocus: index2 === 0,
                tabIndex: -1,
                readOnly: true
              }, index2))
            })
          ]
        }),
        (0, import_jsx_runtime100.jsx)("div", {
          className: "tgui-0e77c7f1a1b82c84",
          children: createChunks(AVAILABLE_PINS, 3).map((rows) => (0, import_jsx_runtime100.jsx)("div", {
            className: "tgui-49b69c407401f76c",
            children: rows.map((element) => {
              let children = element;
              let clickFunction = () => handleClickValue(Number(element));
              if (element === Keys.BACKSPACE) {
                clickFunction = () => handleClickBackspace();
                children = (0, import_jsx_runtime100.jsx)(Icon36Backspace, {
                  className: "tgui-14d79626209a204a"
                });
              }
              return (0, import_jsx_runtime100.jsx)(PinInputButton, {
                onClick: clickFunction,
                children
              }, element);
            })
          }, rows.toString()))
        })
      ]
    }))
  });
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Radio/Radio.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Radio/icons/radio.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime());
var IconRadio = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime101.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime101.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm0 2a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Radio/icons/radio_checked.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime());
var IconRadioChecked = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime102.jsxs)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: [
      (0, import_jsx_runtime102.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm0 2a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z",
        fill: "currentColor"
      }),
      (0, import_jsx_runtime102.jsx)("path", {
        d: "M15 10a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z",
        fill: "currentColor"
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Radio/Radio.js
var Radio = (_param) => {
  var { style, className, disabled } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "disabled"
  ]);
  return (0, import_jsx_runtime103.jsxs)("label", {
    className: classNames("tgui-de477a8e3910f19f", disabled && "tgui-d5c5e7402bfd8c12", className),
    children: [
      (0, import_jsx_runtime103.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "radio",
        className: "tgui-743a4b0f25e5d51b",
        disabled
      })),
      (0, import_jsx_runtime103.jsx)(IconRadio, {
        className: "tgui-bfcd091645843388",
        "aria-hidden": true
      }),
      (0, import_jsx_runtime103.jsx)(IconRadioChecked, {
        className: "tgui-8d2d5ba97b4abd79",
        "aria-hidden": true
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Rating/Rating.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Rating/icons/star.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime());
var IconStar = (props) => (0, import_jsx_runtime104.jsx)("svg", _object_spread_props(_object_spread({
  width: "40",
  height: "40",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), {
  children: (0, import_jsx_runtime104.jsx)("path", {
    d: "M16.228 9.993c1.166-3.164 1.75-4.746 2.598-5.199a2.492 2.492 0 0 1 2.348 0c.849.453 1.432 2.035 2.598 5.199l.562 1.525c.337.914.506 1.372.796 1.715.257.303.58.54.945.694.413.173.895.194 1.86.235l1.608.07c3.338.143 5.006.215 5.694.89a2.56 2.56 0 0 1 .726 2.258c-.164.955-1.472 2.005-4.088 4.104l-1.262 1.011c-.756.607-1.134.91-1.367 1.296-.206.34-.33.725-.361 1.123-.036.45.094.92.353 1.86l.432 1.568c.896 3.253 1.345 4.88.921 5.75a2.518 2.518 0 0 1-1.9 1.395c-.949.137-2.34-.796-5.124-2.663l-1.341-.9c-.805-.54-1.207-.809-1.642-.914a2.488 2.488 0 0 0-1.168 0c-.435.105-.837.375-1.642.914l-1.341.9c-2.783 1.867-4.175 2.8-5.124 2.663a2.518 2.518 0 0 1-1.9-1.396c-.424-.87.025-2.496.921-5.749l.432-1.568c.26-.94.389-1.41.353-1.86a2.563 2.563 0 0 0-.361-1.123c-.233-.386-.611-.689-1.367-1.296l-1.262-1.011c-2.616-2.1-3.924-3.149-4.088-4.104a2.56 2.56 0 0 1 .726-2.258c.688-.675 2.356-.747 5.694-.89l1.608-.07c.965-.041 1.447-.062 1.86-.235.364-.153.688-.391.945-.694.29-.343.459-.8.796-1.715l.562-1.525Z",
    fill: "currentColor",
    opacity: ".8"
  })
}));

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Rating/Rating.js
var MINIMUM_PRECISION = 0.1;
var Rating = ({ precision = 1, max: max2 = 5, onChange, value: valueProp = 0, IconContainer: IconContainer2 = IconStar }) => {
  const [value, setValue] = useCustomEnsuredControl({
    defaultValue: valueProp,
    onChange
  });
  const normalizedPrecision = clamp(precision, MINIMUM_PRECISION, 1);
  const onChangeLabel = (event) => {
    const { target } = event;
    if (target instanceof HTMLInputElement) {
      setValue(parseFloat(target.value));
    }
  };
  const getPickedElementWidth = (elementNumber) => {
    if (elementNumber <= value) {
      return 1;
    }
    const valueRange = elementNumber - value;
    if (valueRange > 0 && valueRange < 1) {
      return 1 - valueRange;
    }
    return void 0;
  };
  const keys = Array.from(Array(max2).keys());
  return (0, import_jsx_runtime105.jsxs)("label", {
    className: "tgui-0487bdb4329cd879",
    onChange: onChangeLabel,
    children: [
      (0, import_jsx_runtime105.jsx)(VisuallyHidden, {
        Component: "input",
        name: "rating",
        type: "radio",
        value: 0
      }),
      keys.map((key) => {
        const elementsWithPrecision = Math.floor(1 / normalizedPrecision);
        const elements = Array.from(Array(elementsWithPrecision).keys());
        const pickedElementWidth = getPickedElementWidth(key + 1);
        return (0, import_jsx_runtime105.jsxs)("label", {
          className: "tgui-6169bc2e9d6fdeb8",
          children: [
            pickedElementWidth !== void 0 && (0, import_jsx_runtime105.jsx)(IconContainer2, {
              className: "tgui-f0faaa15f44569ba",
              style: {
                width: `${pickedElementWidth * 100}%`
              }
            }, "star-picked"),
            (0, import_jsx_runtime105.jsx)(IconContainer2, {}, "star"),
            elements.map((element) => (0, import_jsx_runtime105.jsx)("input", {
              type: "radio",
              value: (key + (element + 1) * normalizedPrecision).toFixed(1),
              name: "rating",
              style: {
                width: `${normalizedPrecision * 100}%`,
                left: `${element * normalizedPrecision * 100}%`
              },
              className: "tgui-52ba7059852e9950"
            }, element))
          ]
        }, key);
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Select/Select.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime());
var Select = (_param) => {
  var { header, before, status, className } = _param, restProps = _object_without_properties(_param, [
    "header",
    "before",
    "status",
    "className"
  ]);
  const platform2 = usePlatform();
  const TypographyComponent = platform2 === "ios" ? Text : Subheadline;
  return (0, import_jsx_runtime106.jsxs)(FormInput, {
    header,
    before,
    status,
    className: classNames("tgui-919c5658483cae11", platform2 === "ios" && "tgui-5edcb8465ee11055", className),
    children: [
      (0, import_jsx_runtime106.jsx)(TypographyComponent, _object_spread({
        Component: "select",
        className: "tgui-a0742fd4c73756f7",
        multiple: false
      }, restProps)),
      (0, import_jsx_runtime106.jsx)(Icon20ChevronDown, {
        "aria-hidden": true,
        className: "tgui-025a45d791e466f6"
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Selectable/Selectable.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Selectable/icons/selectable_base.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime());
var IconSelectableBase = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime107.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime107.jsx)("path", {
      d: "M2.5 10.82 7 15.75l10.5-11.5",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Selectable/icons/selectable_ios.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime());
var IconSelectableIOS = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime108.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime108.jsx)("path", {
      d: "M8.17 18a1.5 1.5 0 0 1-1.2-.63l-4.6-5.82a1.73 1.73 0 0 1-.29-.46A1.42 1.42 0 0 1 2 10.6a1.22 1.22 0 0 1 1.25-1.26c.41 0 .75.18 1.03.54l3.86 5.02 7.52-12.24c.16-.25.32-.42.48-.51.17-.1.38-.16.63-.16A1.2 1.2 0 0 1 18 3.23c0 .15-.02.3-.07.44-.05.15-.12.3-.22.46l-8.32 13.2c-.28.45-.69.67-1.22.67Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Selectable/Selectable.js
var Selectable = (_param) => {
  var { style, className, disabled } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "disabled"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime109.jsxs)("label", {
    className: classNames("tgui-aa094d6480bfa32a", disabled && "tgui-7d31e315f5cc4733", className),
    children: [
      (0, import_jsx_runtime109.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "radio",
        className: "tgui-6988c618806a5171",
        disabled
      })),
      platform2 === "ios" && (0, import_jsx_runtime109.jsx)(IconSelectableIOS, {
        className: "tgui-ad96577f259c5732",
        "aria-hidden": true
      }),
      platform2 === "base" && (0, import_jsx_runtime109.jsx)(IconSelectableBase, {
        className: "tgui-ad96577f259c5732",
        "aria-hidden": true
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/Slider.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Touch/Touch.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime());
var import_react50 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/hooks/useEventListener.js
var import_react49 = __toESM(require_react());
function useEventListener(event, _cb, _options) {
  const cbRef = (0, import_react49.useRef)(_cb);
  useEnhancedEffect(() => {
    cbRef.current = _cb;
  }, [
    _cb
  ]);
  const cb = (0, import_react49.useCallback)((e) => cbRef.current && cbRef.current(e), []);
  const detach = (0, import_react49.useRef)(() => {
  });
  const remove = (0, import_react49.useCallback)(() => {
    detach.current();
    detach.current = () => {
    };
  }, []);
  const add = (0, import_react49.useCallback)((el) => {
    if (!canUseDOM) {
      return;
    }
    remove();
    if (!el) {
      return;
    }
    const options = _object_spread({}, _options);
    el.addEventListener(event, cb, options);
    detach.current = () => el.removeEventListener(event, cb, options);
  }, [
    _options,
    cb,
    event,
    remove
  ]);
  (0, import_react49.useEffect)(() => remove, [
    remove
  ]);
  return (0, import_react49.useMemo)(() => ({
    add,
    remove
  }), [
    add,
    remove
  ]);
}

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Touch/helpers/touch.js
var initGesture = (startX, startY) => ({
  startX,
  startY,
  startT: /* @__PURE__ */ new Date(),
  duration: 0,
  isPressed: true,
  isY: false,
  isX: false,
  isSlideX: false,
  isSlideY: false,
  isSlide: false,
  clientX: 0,
  clientY: 0,
  shiftX: 0,
  shiftY: 0,
  shiftXAbs: 0,
  shiftYAbs: 0
});
var coordX = (e) => {
  if (e.clientX != null) {
    return e.clientX;
  }
  return e.changedTouches && e.changedTouches[0].clientX;
};
var coordY = (e) => {
  if (e.clientY != null) {
    return e.clientY;
  }
  return e.changedTouches && e.changedTouches[0].clientY;
};
var touchEnabled = () => canUseDOM && "ontouchstart" in window;
var getSupportedEvents = () => {
  if (touchEnabled()) {
    return [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel"
    ];
  }
  return [
    "mousedown",
    "mousemove",
    "mouseup",
    "mouseleave"
  ];
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/Touch/Touch.js
var Touch = (_param) => {
  var { Component = "div", onStart, onStartX, onStartY, onMove: _onMove, onMoveX, onMoveY, onLeave, onEnter, onEnd: _onEnd, onEndX, onEndY, onClickCapture, usePointerHover, slideThreshold = 5, useCapture = false, noSlideClick = false, stopPropagation = false } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "onStart",
    "onStartX",
    "onStartY",
    "onMove",
    "onMoveX",
    "onMoveY",
    "onLeave",
    "onEnter",
    "onEnd",
    "onEndX",
    "onEndY",
    "onClickCapture",
    "usePointerHover",
    "slideThreshold",
    "useCapture",
    "noSlideClick",
    "stopPropagation"
  ]);
  const events = (0, import_react50.useMemo)(getSupportedEvents, []);
  const didSlide = (0, import_react50.useRef)(false);
  const gesture = (0, import_react50.useRef)(null);
  const handle = (e, handlers) => {
    stopPropagation && e.stopPropagation();
    handlers.forEach((cb) => {
      var _gesture_current_startT, _gesture_current;
      var _gesture_current_startT_getTime;
      const duration = Date.now() - ((_gesture_current_startT_getTime = (_gesture_current = gesture.current) === null || _gesture_current === void 0 ? void 0 : (_gesture_current_startT = _gesture_current.startT) === null || _gesture_current_startT === void 0 ? void 0 : _gesture_current_startT.getTime()) !== null && _gesture_current_startT_getTime !== void 0 ? _gesture_current_startT_getTime : 0);
      cb && cb(_object_spread_props(_object_spread({}, gesture.current), {
        duration,
        originalEvent: e
      }));
    });
  };
  const listenerParams = {
    capture: useCapture,
    passive: false
  };
  const listeners = [
    useEventListener(events[1], onMove, listenerParams),
    useEventListener(events[2], onEnd, listenerParams),
    useEventListener(events[3], onEnd, listenerParams)
  ];
  const subscribe = (el) => {
    if (!el) {
      return;
    }
    listeners.forEach((l) => l.add(el));
  };
  const unsubscribe = () => {
    listeners.forEach((l) => l.remove());
  };
  const enterHandler = useEventListener(usePointerHover ? "pointerenter" : "mouseenter", onEnter);
  const leaveHandler = useEventListener(usePointerHover ? "pointerleave" : "mouseleave", onLeave);
  const startHandler = useEventListener(events[0], (e) => {
    gesture.current = initGesture(coordX(e), coordY(e));
    handle(e, [
      onStart,
      onStartX,
      onStartY
    ]);
    subscribe(touchEnabled() ? (
      // see: #235, #1968, https://stackoverflow.com/a/45760014
      e.target
    ) : (
      // if the pointer goes outside the container.
      // Can be fixed by PointerEvents' setPointerCapture later
      window.document
    ));
  }, {
    capture: useCapture,
    passive: false
  });
  const containerRef = (0, import_react50.useRef)();
  useEnhancedEffect(() => {
    const el = containerRef.current;
    if (el) {
      enterHandler.add(el);
      leaveHandler.add(el);
      startHandler.add(el);
    }
  }, [
    Component
  ]);
  function onMove(e) {
    var _gesture_current;
    const { isPressed, isX, isY, startX = 0, startY = 0 } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};
    if (isPressed) {
      var _gesture_current1;
      const clientX = coordX(e);
      const clientY = coordY(e);
      const shiftX = clientX - startX;
      const shiftY = clientY - startY;
      const shiftXAbs = Math.abs(shiftX);
      const shiftYAbs = Math.abs(shiftY);
      if (!!e.touches && e.touches.length > 1) {
        onEnd(e);
        return;
      }
      if (!isX && !isY) {
        const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;
        const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;
        const willBeSlidedX = willBeX && (!!onMoveX || !!_onMove);
        const willBeSlidedY = willBeY && (!!onMoveY || !!_onMove);
        if (gesture.current) {
          Object.assign(gesture.current, {
            isY: willBeY,
            isX: willBeX,
            isSlideX: willBeSlidedX,
            isSlideY: willBeSlidedY,
            isSlide: willBeSlidedX || willBeSlidedY
          });
        }
      }
      if ((_gesture_current1 = gesture.current) === null || _gesture_current1 === void 0 ? void 0 : _gesture_current1.isSlide) {
        Object.assign(gesture.current, {
          clientX,
          clientY,
          shiftX,
          shiftY,
          shiftXAbs,
          shiftYAbs
        });
        handle(e, [
          _onMove,
          gesture.current.isSlideX && onMoveX,
          gesture.current.isSlideY && onMoveY
        ]);
      }
    }
  }
  function onEnd(e) {
    var _gesture_current;
    const { isPressed, isSlide, isSlideX, isSlideY } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};
    if (isPressed) {
      handle(e, [
        _onEnd,
        isSlideY && onEndY,
        isSlideX && onEndX
      ]);
    }
    const isTouchEnabled = touchEnabled();
    if (isTouchEnabled && isSlide) {
      didSlide.current = false;
    } else {
      didSlide.current = Boolean(isSlide);
    }
    gesture.current = {};
    if (isTouchEnabled) {
      onLeave && onLeave(e);
    }
    unsubscribe();
  }
  const onDragStart = (e) => {
    const target = e.target;
    if (target.tagName === "A" || target.tagName === "IMG") {
      e.preventDefault();
    }
  };
  const postGestureClick = (e) => {
    if (!didSlide.current) {
      onClickCapture && onClickCapture(e);
      return;
    }
    if (noSlideClick) {
      e.stopPropagation();
      e.preventDefault();
    } else {
      onClickCapture && onClickCapture(e);
    }
    didSlide.current = false;
  };
  return (0, import_jsx_runtime110.jsx)(Component, _object_spread_props(_object_spread({}, restProps), {
    onDragStart,
    onClickCapture: postGestureClick,
    ref: containerRef
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/components/SliderSteps/SliderSteps.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime());
var SliderSteps = ({ steps }) => {
  const platform2 = usePlatform();
  return (0, import_jsx_runtime111.jsx)(import_jsx_runtime111.Fragment, {
    children: steps.map(({ isPassed, XCoordinate }) => (0, import_jsx_runtime111.jsx)("div", {
      className: classNames("tgui-b632646f586ff14d", {
        ["tgui-7951a89b824476b3"]: platform2 === "ios",
        ["tgui-2b0a006b5a9ffd68"]: isPassed
      }),
      style: {
        left: `${XCoordinate}%`
      }
    }, XCoordinate))
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/components/SliderThumb/SliderThumb.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime());
var import_react51 = __toESM(require_react());
var SliderThumb = (0, import_react51.forwardRef)((_param, ref) => {
  var { className, inputProps, withTooltip } = _param, restProps = _object_without_properties(_param, [
    "className",
    "inputProps",
    "withTooltip"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime112.jsx)("span", _object_spread_props(_object_spread({
    className: classNames("tgui-83b7253102c6addc", platform2 === "ios" && "tgui-96f5864d281f94a8", className)
  }, restProps), {
    children: (0, import_jsx_runtime112.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, inputProps), {
      Component: "input",
      type: "range",
      ref,
      className: classNames("tgui-abdeb837bfc726cb", className),
      "aria-orientation": "horizontal"
    }))
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/hooks/useSlider.js
var import_react52 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/hooks/helpers/html.js
var extractSliderAriaAttributes = (restProps) => {
  const { "aria-label": ariaLabel, "aria-valuetext": ariaValueText, "aria-labelledby": ariaLabelledBy } = restProps, restPropsWithoutAria = _object_without_properties(restProps, [
    "aria-label",
    "aria-valuetext",
    "aria-labelledby"
  ]);
  return _object_spread({
    aria: {
      ariaLabel,
      ariaValueText,
      ariaLabelledBy
    }
  }, restPropsWithoutAria);
};
var getDraggingTypeByTargetDataset = (target) => {
  if (!target) {
    return null;
  }
  if ([
    "start",
    "end"
  ].includes(target.dataset.type || "")) {
    return target.dataset.type;
  }
  return null;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/hooks/helpers/math/index.js
var getDecimalPrecision = (num) => {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
};
var roundValueToStep = (value, step, min2) => {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
};
var roundedClampWithStep = (val, min2, max2, step) => {
  if (step == null || step <= 0) {
    return clamp(val, min2, max2);
  }
  const roundedValue = roundValueToStep(val, step, min2);
  return clamp(roundedValue, min2, max2);
};
var scaleAndClampValue = (value, from, to, options = {}) => {
  const scaled = (value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];
  return roundedClampWithStep(scaled, to[0], to[1], options.step);
};
var toPercent = (v, min2, max2) => (v - min2) / (max2 - min2) * 100;
var offsetXToScaledValue = (startX, width, min2, max2, step) => {
  return scaleAndClampValue(startX, [
    0,
    width
  ], [
    min2,
    max2
  ], {
    step
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/hooks/helpers/state.js
var updateInternalStateValue = (currentState, newValue, minValue, maxValue, draggingType) => {
  const [currentStartValue, currentEndValue] = currentState;
  if (currentEndValue === null) {
    return [
      clamp(newValue, minValue, maxValue),
      null
    ];
  }
  switch (draggingType) {
    case "start":
      return newValue > currentEndValue ? [
        currentEndValue,
        currentEndValue
      ] : [
        clamp(newValue, minValue, maxValue),
        currentEndValue
      ];
    case "end":
      return newValue < currentStartValue ? [
        currentStartValue,
        currentStartValue
      ] : [
        currentStartValue,
        clamp(newValue, minValue, maxValue)
      ];
    case null:
    default:
      return currentState;
  }
};
var updateInternalStateByNativeChange = (currentState, newValue, draggingType) => {
  const [currentStartValue, currentEndValue] = currentState;
  switch (draggingType) {
    case "start":
      return [
        newValue,
        currentEndValue
      ];
    case "end":
      return [
        currentStartValue,
        newValue
      ];
    case null:
    default:
      return currentState;
  }
};
var isMultipleValues = (value) => {
  return value[1] !== null;
};
var MINIMUM_DIFFERENCE_BETWEEN_START_AND_END = 0.1;
var determineSnapDirection = (currentValues2, newValue, draggingType) => {
  if (draggingType === "start" || draggingType === "end") {
    return draggingType;
  }
  const [startRaw, endRaw] = currentValues2;
  const start = endRaw !== null ? startRaw - MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : startRaw;
  const end = endRaw !== null ? endRaw + MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : 0;
  return Math.abs(start - newValue) <= Math.abs(end - newValue) ? "start" : "end";
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/hooks/useSlider.js
var useSlider = (_param) => {
  var { step = 1, min: min2 = 0, max: max2 = 100, value: valueProp, multiple: multipleProp, defaultValue = multipleProp ? [
    min2,
    max2
  ] : min2, disabled, getAriaLabel, getAriaValueText, onChange } = _param, restProps = _object_without_properties(_param, [
    "step",
    "min",
    "max",
    "value",
    "multiple",
    "defaultValue",
    "disabled",
    "getAriaLabel",
    "getAriaValueText",
    "onChange"
  ]);
  const isControlled = valueProp !== void 0;
  const [localValue, setValue] = (0, import_react52.useState)(defaultValue);
  const value = (0, import_react52.useMemo)(() => {
    const resolvedValue = isControlled ? valueProp : localValue;
    return Array.isArray(resolvedValue) ? [
      clamp(resolvedValue[0], min2, max2),
      clamp(resolvedValue[1], min2, max2)
    ] : [
      clamp(resolvedValue, min2, max2),
      null
    ];
  }, [
    isControlled,
    valueProp,
    localValue,
    min2,
    max2
  ]);
  const [startValue, endValue] = value;
  const multiple = multipleProp && endValue !== null;
  const gesture = (0, import_react52.useRef)({
    dragging: null,
    startX: 0,
    containerWidth: 0
  }).current;
  const thumbsContainerRef = (0, import_react52.useRef)(null);
  const thumbStartInputRef = (0, import_react52.useRef)(null);
  const thumbEndInputRef = (0, import_react52.useRef)(null);
  const changeValue = (nextValue, event) => {
    if (disabled || isEqual(nextValue[0], nextValue[1])) {
      return;
    }
    if (multipleProp) {
      if (isMultipleValues(nextValue)) {
        !isControlled && setValue(nextValue);
        onChange && onChange(nextValue, event);
      }
    } else {
      !isControlled && setValue(nextValue[0]);
      onChange && onChange(nextValue[0], event);
    }
  };
  const handlePointerStart = (event) => {
    if (!thumbsContainerRef.current) {
      return;
    }
    const { left: nextContainerX, width: nextContainerWidth } = thumbsContainerRef.current.getBoundingClientRect();
    if (!(event.originalEvent.target instanceof HTMLElement)) {
      return;
    }
    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);
    const nextStartX = event.startX - nextContainerX;
    const nextValue = offsetXToScaledValue(nextStartX, nextContainerWidth, min2, max2, step);
    const nextDragging = determineSnapDirection(value, nextValue, foundDraggingType);
    gesture.dragging = nextDragging;
    gesture.containerWidth = nextContainerWidth;
    gesture.startX = nextStartX;
    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min2, max2, nextDragging);
    const [nextStartValue, nextEndValue] = updatedInternalStateValue;
    if (thumbStartInputRef.current && (foundDraggingType === "start" || nextStartValue !== startValue && nextEndValue === endValue)) {
      thumbStartInputRef.current.focus();
      event.originalEvent.preventDefault();
    } else if (thumbEndInputRef.current && (foundDraggingType === "end" || nextEndValue !== endValue && nextStartValue === startValue)) {
      thumbEndInputRef.current.focus();
      event.originalEvent.preventDefault();
    }
    changeValue(updatedInternalStateValue, event);
    event.originalEvent.stopPropagation();
  };
  const handlePointerMove = (event) => {
    const { startX, containerWidth, dragging } = gesture;
    const { shiftX = 0 } = event;
    const nextStartX = startX + shiftX;
    const nextValue = offsetXToScaledValue(nextStartX, containerWidth, min2, max2, step);
    changeValue(updateInternalStateValue(value, nextValue, min2, max2, dragging), event);
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const handlePointerEnd = (event) => {
    gesture.dragging = null;
    event.originalEvent.stopPropagation();
  };
  const handleChangeByNativeInput = (event) => {
    changeValue(updateInternalStateByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);
  };
  const _extractSliderAriaAttributes = extractSliderAriaAttributes(restProps), { aria } = _extractSliderAriaAttributes, restPropsWithoutArea = _object_without_properties(_extractSliderAriaAttributes, [
    "aria"
  ]);
  const getInputProps = (isEndInput) => {
    const index2 = isEndInput ? 1 : 0;
    return {
      "data-type": isEndInput ? "end" : "start",
      step,
      min: min2,
      value: isEndInput && multiple ? endValue : startValue,
      max: !isEndInput && multiple ? endValue : max2,
      disabled,
      "aria-label": getAriaLabel ? getAriaLabel(index2) : aria.ariaLabel,
      "aria-valuetext": getAriaValueText ? getAriaValueText(startValue, index2) : aria.ariaValueText,
      "aria-labelledby": aria.ariaLabelledBy,
      onChange: handleChangeByNativeInput
    };
  };
  const getStepsCoordinates = () => {
    if (step === 1) {
      return void 0;
    }
    const steps = [];
    const stepsCount = Math.floor((max2 - min2) / step);
    for (let i = 0; i <= stepsCount; i += 1) {
      const stepValue = min2 + i * step;
      const isPassed = multiple ? stepValue >= startValue && stepValue <= endValue : stepValue <= startValue;
      steps.push({
        isPassed,
        XCoordinate: toPercent(stepValue, min2, max2)
      });
    }
    return steps;
  };
  return {
    steps: getStepsCoordinates(),
    multiple,
    containerProps: restPropsWithoutArea,
    startValueInPercent: toPercent(startValue, min2, max2),
    endReversedValueInPercent: multiple ? toPercent(endValue, min2, max2) : 0,
    thumbsContainerRef,
    thumbStartInputRef,
    thumbEndInputRef,
    handlePointerStart,
    handlePointerMove,
    handlePointerEnd,
    getInputProps
  };
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Slider/Slider.js
var Slider = (_param) => {
  var { className, disabled, before, after } = _param, restProps = _object_without_properties(_param, [
    "className",
    "disabled",
    "before",
    "after"
  ]);
  const platform2 = usePlatform();
  const { steps, multiple, containerProps, startValueInPercent, endReversedValueInPercent, thumbsContainerRef, thumbStartInputRef, thumbEndInputRef, handlePointerStart, handlePointerMove, handlePointerEnd, getInputProps } = useSlider(restProps);
  return (0, import_jsx_runtime113.jsxs)("div", {
    className: classNames("tgui-717c3649db8d5af2", platform2 === "ios" && "tgui-d2e2a2e28ef0f746", disabled && "tgui-c591a831de13ba23", className),
    children: [
      hasReactNode(before) && (0, import_jsx_runtime113.jsx)("div", {
        className: "tgui-6598607160233201",
        children: before
      }),
      (0, import_jsx_runtime113.jsxs)(Touch, _object_spread_props(_object_spread({}, containerProps), {
        className: "tgui-35faba867393ce37",
        onStart: disabled ? void 0 : handlePointerStart,
        onMove: disabled ? void 0 : handlePointerMove,
        onEnd: disabled ? void 0 : handlePointerEnd,
        children: [
          (0, import_jsx_runtime113.jsx)("div", {
            className: "tgui-e11a455378c63b15",
            children: steps !== void 0 && (0, import_jsx_runtime113.jsx)(SliderSteps, {
              steps
            })
          }),
          (0, import_jsx_runtime113.jsx)("div", {
            className: "tgui-4de4feff2dcc975c",
            style: multiple ? {
              left: `${startValueInPercent}%`,
              right: `${100 - endReversedValueInPercent}%`
            } : {
              width: `${startValueInPercent}%`
            }
          }),
          (0, import_jsx_runtime113.jsxs)("div", {
            ref: thumbsContainerRef,
            className: "tgui-7fe9f0fbc9771947",
            children: [
              (0, import_jsx_runtime113.jsx)(SliderThumb, {
                "data-type": "start",
                ref: thumbStartInputRef,
                style: {
                  left: `${startValueInPercent}%`,
                  zIndex: multiple && startValueInPercent >= 50 ? 3 : void 0
                },
                inputProps: getInputProps(false)
              }),
              multiple && (0, import_jsx_runtime113.jsx)(SliderThumb, {
                "data-type": "end",
                ref: thumbEndInputRef,
                style: {
                  left: `${endReversedValueInPercent}%`
                },
                inputProps: getInputProps(true)
              })
            ]
          })
        ]
      })),
      hasReactNode(after) && (0, import_jsx_runtime113.jsx)("div", {
        className: "tgui-a56564bcfd4b56e5",
        children: after
      })
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Switch/Switch.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime());
var platformStyles2 = {
  base: "tgui-2776944549f431fc",
  ios: "tgui-b70ccb0e7742541a"
};
var Switch = (_param) => {
  var { style, className, disabled, children } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "disabled",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime114.jsxs)("label", {
    className: classNames("tgui-a1dc55b304d32032", platformStyles2[platform2], disabled && "tgui-57a00e000de7483d", className),
    children: [
      (0, import_jsx_runtime114.jsx)(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
        Component: "input",
        type: "checkbox",
        className: "tgui-edfaab8ff474b0de",
        disabled
      })),
      (0, import_jsx_runtime114.jsx)("div", {
        "aria-hidden": true,
        className: "tgui-3acc6d0262399734"
      }),
      children
    ]
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Form/Textarea/Textarea.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime());
var Textarea = (_param) => {
  var { type = "text", header, status, className } = _param, restProps = _object_without_properties(_param, [
    "type",
    "header",
    "status",
    "className"
  ]);
  const platform2 = usePlatform();
  const TypographyComponent = platform2 === "ios" ? Text : Subheadline;
  return (0, import_jsx_runtime115.jsx)(FormInput, {
    header,
    status,
    className: classNames("tgui-54ba5b4c7f1fd05a", platform2 === "ios" && "tgui-2453b62de8016bfa", className),
    children: (0, import_jsx_runtime115.jsx)(TypographyComponent, _object_spread({
      Component: "textarea",
      className: "tgui-d40ec83150e66029",
      type
    }, restProps))
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Layout/FixedLayout/FixedLayout.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime());
var verticalStyles = {
  top: "tgui-d83e15d73344cdc0",
  bottom: "tgui-01790b7e59088ea5"
};
var FixedLayout = (_param) => {
  var { Component = "div", vertical = "bottom", className, children } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "vertical",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime116.jsx)(Component, _object_spread_props(_object_spread({
    className: classNames("tgui-7a5facec9dc28fae", vertical && verticalStyles[vertical], className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Layout/Tabbar/Tabbar.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Layout/Tabbar/components/TabbarItem/TabbarItem.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime());
var TabbarItem = (_param) => {
  var { selected, text, children, className } = _param, restProps = _object_without_properties(_param, [
    "selected",
    "text",
    "children",
    "className"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime117.jsxs)(Tappable, _object_spread_props(_object_spread({
    Component: "button",
    interactiveAnimation: "opacity",
    className: classNames("tgui-64cd0db020a9bacf", platform2 === "ios" && "tgui-ecbb746748ea4134", selected && "tgui-e6658d0b8927f95e", className)
  }, restProps), {
    children: [
      hasReactNode(children) && (0, import_jsx_runtime117.jsx)("div", {
        className: "tgui-44d48e11585af170",
        children
      }),
      hasReactNode(text) && (0, import_jsx_runtime117.jsx)(Caption, {
        className: "tgui-aeab497081949a15",
        weight: "2",
        level: platform2 === "ios" ? "2" : "1",
        children: text
      })
    ]
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Layout/Tabbar/Tabbar.js
var Tabbar = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime118.jsx)(FixedLayout, _object_spread_props(_object_spread({
    className: classNames("tgui-53cb2ebed0c3b08f", platform2 === "ios" && "tgui-a2b4713d67582227")
  }, restProps), {
    children
  }));
};
Tabbar.Item = TabbarItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Breadcrumbs/Breadcrumbs.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime());
var import_react53 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Breadcrumbs/components/BreadCrumbsItem/BreadCrumbsItem.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime());
var BreadCrumbsItem = (_param) => {
  var { Component = "div", className, children } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime119.jsx)(Component, _object_spread_props(_object_spread({
    className: classNames("tgui-32fe6ce00169d72e", className)
  }, restProps), {
    children: (0, import_jsx_runtime119.jsx)(Subheadline, {
      level: "2",
      weight: "2",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Breadcrumbs/icons/dot.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime());
var IconDot = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime120.jsx)("svg", _object_spread_props(_object_spread({
    width: "21",
    height: "20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime120.jsx)("circle", {
      cx: "10.5",
      cy: "10",
      r: "2",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Breadcrumbs/icons/slash.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime());
var IconSlash = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime121.jsx)("svg", _object_spread_props(_object_spread({
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime121.jsx)("path", {
      d: "M13 5L8 15",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Breadcrumbs/Breadcrumbs.js
var Breadcrumbs = ({ divider = "dot", className, children }) => (0, import_jsx_runtime122.jsx)("div", {
  className: classNames("tgui-68fc52f1068b8e16", className),
  children: import_react53.Children.map(children, (child, index2) => (0, import_jsx_runtime122.jsxs)(import_jsx_runtime122.Fragment, {
    children: [
      child,
      index2 !== import_react53.Children.count(children) - 1 && (0, import_jsx_runtime122.jsxs)("div", {
        className: "tgui-0eddcd83377979c2",
        children: [
          divider === "dot" && (0, import_jsx_runtime122.jsx)(IconDot, {}),
          divider === "slash" && (0, import_jsx_runtime122.jsx)(IconSlash, {}),
          divider === "chevron" && (0, import_jsx_runtime122.jsx)(Icon16Chevron, {
            className: "tgui-a9c3d618b6e43d64"
          })
        ]
      })
    ]
  }))
});
Breadcrumbs.Item = BreadCrumbsItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/CompactPagination/CompactPagination.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/CompactPagination/components/CompactPaginationItem/CompactPaginationItem.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime());
var CompactPaginationItem = (_param) => {
  var { selected, className, children } = _param, restProps = _object_without_properties(_param, [
    "selected",
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime123.jsx)("button", _object_spread_props(_object_spread({
    type: "button",
    role: "tab",
    "aria-selected": selected,
    className: classNames("tgui-747563e660315b07", selected && "tgui-6d14364fac453a65", className)
  }, restProps), {
    children: hasReactNode(children) ? (0, import_jsx_runtime123.jsx)(VisuallyHidden, {
      children
    }) : void 0
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/CompactPagination/CompactPagination.js
var modeStyles7 = {
  default: void 0,
  ambient: "tgui-15adbef8fe5efed9",
  white: "tgui-cdc228e9d92dac5b"
};
var CompactPagination = (_param) => {
  var { mode = "default", children, className } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "className"
  ]);
  return (0, import_jsx_runtime124.jsx)("div", _object_spread_props(_object_spread({
    role: "tablist",
    className: classNames("tgui-442a9579d6c19dc4", modeStyles7[mode], className)
  }, restProps), {
    children
  }));
};
CompactPagination.Item = CompactPaginationItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Link/Link.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime());
var Link = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime125.jsx)("a", _object_spread_props(_object_spread({
    className: classNames("tgui-bfabaddd169233a9", className)
  }, restProps), {
    children
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Pagination/Pagination.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime());

// node_modules/@telegram-apps/telegram-ui/dist/icons/24/chevron_left.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime());
var Icon24ChevronLeft = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime126.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime126.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M15.7071 3.79289c-.3905-.39052-1.0237-.39052-1.4142 0L6.79289 11.2929c-.39052.3905-.39052 1.0237 0 1.4142l7.50001 7.5c.3905.3905 1.0237.3905 1.4142 0 .3905-.3905.3905-1.0237 0-1.4142L8.91421 12l6.79289-6.79289c.3905-.39053.3905-1.02369 0-1.41422Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/icons/24/chevron_right.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime());
var Icon24ChevronRight = (_param) => {
  var restProps = _extends({}, _object_destructuring_empty(_param));
  return (0, import_jsx_runtime127.jsx)("svg", _object_spread_props(_object_spread({
    width: "24",
    height: "24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, restProps), {
    children: (0, import_jsx_runtime127.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M7.29289 3.79289c.39053-.39052 1.02369-.39052 1.41422 0l7.49999 7.50001c.3905.3905.3905 1.0237 0 1.4142l-7.49999 7.5c-.39053.3905-1.02369.3905-1.41422 0-.39052-.3905-.39052-1.0237 0-1.4142L14.0858 12 7.29289 5.20711c-.39052-.39053-.39052-1.02369 0-1.41422Z",
      fill: "currentColor"
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Pagination/hooks/enum.js
var PaginationType;
(function(PaginationType2) {
  PaginationType2["Page"] = "page";
  PaginationType2["Next"] = "next";
  PaginationType2["Previous"] = "previous";
  PaginationType2["StartEllipsis"] = "start-ellipsis";
  PaginationType2["EndEllipsis"] = "end-ellipsis";
})(PaginationType || (PaginationType = {}));

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Pagination/hooks/usePagination.js
var import_react54 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/array.js
var range = (startPosition, endPosition) => {
  const length = endPosition - startPosition + 1;
  return Array.from({
    length
  }, (_, i) => startPosition + i);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Pagination/hooks/usePagination.js
var usePagination = ({ boundaryCount = 1, count: count3 = 1, defaultPage = 1, hideNextButton = false, hidePrevButton = false, onChange, page: pageProp, siblingCount = 1 }) => {
  const [page, setPageState] = (0, import_react54.useState)(pageProp === void 0 ? defaultPage : pageProp);
  const handleClick = (event, value) => {
    if (!pageProp) {
      setPageState(value);
    }
    if (onChange) {
      onChange(event, value);
    }
  };
  const startPages = range(1, Math.min(boundaryCount, count3));
  const endPages = range(Math.max(count3 - boundaryCount + 1, boundaryCount + 1), count3);
  const siblingsStart = Math.max(
    Math.min(
      // Natural start
      page - siblingCount,
      // Lower boundary when page is high
      count3 - boundaryCount - siblingCount * 2 - 1
    ),
    // Greater than startPages
    boundaryCount + 2
  );
  const siblingsEnd = Math.min(
    Math.max(
      // Natural end
      page + siblingCount,
      // Upper boundary when page is low
      boundaryCount + siblingCount * 2 + 2
    ),
    // Less than endPages
    endPages.length > 0 ? endPages[0] - 2 : count3 - 1
  );
  const itemList = [
    ...hidePrevButton ? [] : [
      PaginationType.Previous
    ],
    ...startPages,
    // Start ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsStart > boundaryCount + 2 ? [
      PaginationType.StartEllipsis
    ] : boundaryCount + 1 < count3 - boundaryCount ? [
      boundaryCount + 1
    ] : [],
    // Sibling pages
    ...range(siblingsStart, siblingsEnd),
    // End ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsEnd < count3 - boundaryCount - 1 ? [
      PaginationType.EndEllipsis
    ] : count3 - boundaryCount > boundaryCount ? [
      count3 - boundaryCount
    ] : [],
    ...endPages,
    ...hideNextButton ? [] : [
      PaginationType.Next
    ]
  ];
  const buttonPage = (type) => {
    switch (type) {
      case "previous":
        return page - 1;
      case "next":
        return page + 1;
      default:
        return null;
    }
  };
  return itemList.map((typeOrPageNumber) => {
    if (typeof typeOrPageNumber === "number") {
      return {
        onClick: (event) => handleClick(event, typeOrPageNumber),
        type: PaginationType.Page,
        page: typeOrPageNumber,
        selected: typeOrPageNumber === page,
        disabled: false,
        "aria-current": typeOrPageNumber === page ? "true" : void 0
      };
    }
    return {
      onClick: (event) => handleClick(event, buttonPage(typeOrPageNumber) || 0),
      type: typeOrPageNumber,
      page: buttonPage(typeOrPageNumber),
      selected: false,
      disabled: ![
        PaginationType.StartEllipsis,
        PaginationType.EndEllipsis
      ].includes(typeOrPageNumber) && (typeOrPageNumber === PaginationType.Next ? page >= count3 : page <= 1)
    };
  });
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/Pagination/Pagination.js
var Pagination = (_param) => {
  var { boundaryCount, count: count3, defaultPage, hideNextButton, hidePrevButton, onChange, page, disabled, siblingCount, className } = _param, restProps = _object_without_properties(_param, [
    "boundaryCount",
    "count",
    "defaultPage",
    "hideNextButton",
    "hidePrevButton",
    "onChange",
    "page",
    "disabled",
    "siblingCount",
    "className"
  ]);
  const paginationItems = usePagination({
    boundaryCount,
    count: count3,
    defaultPage,
    hideNextButton,
    hidePrevButton,
    onChange,
    page,
    siblingCount
  });
  const getPaginationChild = (item) => {
    switch (item.type) {
      case PaginationType.Previous:
        return (0, import_jsx_runtime128.jsx)(Icon24ChevronLeft, {
          className: "tgui-2636b28cb21c42cc"
        });
      case PaginationType.Next:
        return (0, import_jsx_runtime128.jsx)(Icon24ChevronRight, {
          className: "tgui-2636b28cb21c42cc"
        });
      case PaginationType.StartEllipsis:
      case PaginationType.EndEllipsis:
        return "...";
      default:
        return item.page;
    }
  };
  return (0, import_jsx_runtime128.jsx)("div", _object_spread_props(_object_spread({
    role: "tablist",
    className: classNames("tgui-38580a5c868cecc4", disabled && "tgui-645f8efe8c9c3cc5", className),
    "aria-disabled": disabled
  }, restProps), {
    children: paginationItems.map((item) => {
      const isEllipsis = [
        PaginationType.StartEllipsis,
        PaginationType.EndEllipsis
      ].includes(item.type);
      return (0, import_jsx_runtime128.jsx)(Headline, {
        Component: isEllipsis ? "div" : "button",
        weight: "2",
        className: classNames("tgui-8dab5cf704c88e82", {
          ["tgui-670c6b2f3c8df445"]: isEllipsis,
          ["tgui-64016be270020f33"]: item.selected,
          ["tgui-a43e090d3501d4ca"]: item.disabled
        }),
        "aria-disabled": item.disabled || void 0,
        "aria-current": item["aria-current"],
        onClick: item.disabled ? void 0 : item.onClick,
        children: getPaginationChild(item)
      }, `${item.type}${item.page}`);
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/SegmentedControl/SegmentedControl.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime());
var import_react55 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/SegmentedControl/components/SegmentedControlItem/SegmentedControlItem.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime());
var SegmentedControlItem = (_param) => {
  var { selected, className, children } = _param, restProps = _object_without_properties(_param, [
    "selected",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime129.jsx)(Tappable, _object_spread_props(_object_spread({
    role: "tab",
    Component: "button",
    className: classNames("tgui-bbfb272d22eb23e8", platform2 === "ios" && "tgui-513fce1023cbbd63", className)
  }, restProps), {
    children: (0, import_jsx_runtime129.jsx)(Caption, {
      weight: selected ? "2" : "3",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/SegmentedControl/SegmentedControl.js
var SegmentedControl = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  const childrenAsArray = import_react55.Children.toArray(children);
  const checkedIndex = childrenAsArray.findIndex((option) => {
    return (0, import_react55.isValidElement)(option) && option.props.selected;
  });
  const translateX = `translateX(${100 * checkedIndex}%)`;
  return (0, import_jsx_runtime130.jsx)("div", _object_spread_props(_object_spread({
    role: "tablist",
    className: classNames("tgui-71259e3311d7116e", platform2 === "ios" && "tgui-16c6b1986a48e2b5", className)
  }, restProps), {
    children: (0, import_jsx_runtime130.jsxs)("div", {
      className: "tgui-b0a9057ab5d33005",
      children: [
        checkedIndex > -1 && (0, import_jsx_runtime130.jsx)("div", {
          "aria-hidden": true,
          className: "tgui-31f461ccfea23ec3",
          style: {
            width: `${100 / childrenAsArray.length}%`,
            transform: translateX
          }
        }),
        children
      ]
    })
  }));
};
SegmentedControl.Item = SegmentedControlItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/TabsList/TabsList.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime());
var import_react56 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/TabsList/components/TabsItem/TabsItem.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime());
var TabsItem = (_param) => {
  var { selected, className, children } = _param, restProps = _object_without_properties(_param, [
    "selected",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  const iosWeight = selected ? "1" : "2";
  return (0, import_jsx_runtime131.jsx)(Tappable, _object_spread_props(_object_spread({
    role: "tab",
    Component: "button",
    className: classNames("tgui-96892ceed80c1bf3", selected && "tgui-44ea091aea23df33", className)
  }, restProps), {
    children: (0, import_jsx_runtime131.jsx)(Text, {
      weight: platform2 === "ios" ? iosWeight : "2",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Navigation/TabsList/TabsList.js
var TabsList = (_param) => {
  var { className, children } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children"
  ]);
  const childrenAsArray = import_react56.Children.toArray(children);
  const checkedIndex = childrenAsArray.findIndex((option) => {
    return (0, import_react56.isValidElement)(option) && option.props.selected;
  });
  const translateX = `translateX(${100 * checkedIndex}%)`;
  return (0, import_jsx_runtime132.jsxs)("div", _object_spread_props(_object_spread({
    role: "tablist",
    className: classNames("tgui-89d3925598b8fd68", className)
  }, restProps), {
    children: [
      checkedIndex > -1 && (0, import_jsx_runtime132.jsx)("div", {
        "aria-hidden": true,
        className: "tgui-8e986e14448c29e6",
        style: {
          width: `${100 / childrenAsArray.length}%`,
          transform: translateX
        }
      }),
      children
    ]
  }));
};
TabsList.Item = TabsItem;

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/Modal.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime());
var import_react63 = __toESM(require_react());

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var React27 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React3 = __toESM(require_react(), 1);
function setRef2(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef2(ref, node));
}
function useComposedRefs(...refs) {
  return React3.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context = React4.createContext(defaultContext);
  function Provider(props) {
    const { children, ...context } = props;
    const value = React4.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime133.jsx)(Context.Provider, { value, children });
  }
  function useContext22(consumerName) {
    const context = React4.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider.displayName = rootComponentName + "Provider";
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React4.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = React4.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime133.jsx)(Context.Provider, { value, children });
    }
    function useContext22(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = React4.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React4.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React4.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React4.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var useLayoutEffect22 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React5.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React6["useId".toString()] || (() => void 0);
var count = 0;
function useId3(deterministicId) {
  const [id, setId] = React6.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React7.useRef(callback);
  React7.useEffect(() => {
    callbackRef.current = callback;
  });
  return React7.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React8.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React8.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React8.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React8.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React12 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var Slot = React9.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React9.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React9.Children.count(newElement) > 1) return React9.Children.only(null);
        return React9.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime134.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React9.isValidElement(newElement) ? React9.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime134.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React9.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React9.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React9.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React9.Children.count(children) > 1 ? React9.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime134.jsx)(import_jsx_runtime134.Fragment, { children });
};
function isSlottable(child) {
  return React9.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React10.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime135.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM2.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React11 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React11.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React12.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React12.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React12.useContext(DismissableLayerContext);
    const [node, setNode] = React12.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React12.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React12.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React12.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React12.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime136.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React12.forwardRef((props, forwardedRef) => {
  const context = React12.useContext(DismissableLayerContext);
  const ref = React12.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React12.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime136.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React12.useRef(false);
  const handleClickRef = React12.useRef(() => {
  });
  React12.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React12.useRef(false);
  React12.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React13 = __toESM(require_react(), 1);
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React13.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React13.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React13.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React13.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React13.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React13.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React13.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime137.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React14.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React14.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? import_react_dom5.default.createPortal((0, import_jsx_runtime138.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var ReactDOM4 = __toESM(require_react_dom(), 1);
var React15 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React15.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          ReactDOM4.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React16.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React26 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React21 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react57 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react57.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React17 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React17.useLayoutEffect : React17.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React18 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react58 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React19 = __toESM(require_react());
var import_react59 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React20 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React20.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React21.forwardRef(function(props, parentRef) {
  var ref = React21.useRef(null);
  var _a = React21.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React21.createElement(
    React21.Fragment,
    null,
    enabled && React21.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React21.cloneElement(React21.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React21.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React25 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React24 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React23 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React23.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React24.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React24.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React24.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React25.useRef([]);
  var touchStartRef = React25.useRef([0, 0]);
  var activeAxis = React25.useRef();
  var id = React25.useState(idCounter++)[0];
  var Style2 = React25.useState(styleSingleton)[0];
  var lastProps = React25.useRef(props);
  React25.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React25.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React25.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React25.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React25.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React25.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React25.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React25.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React25.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React25.createElement(
    React25.Fragment,
    null,
    inert ? React25.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React25.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React26.forwardRef(function(props, ref) {
  return React26.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React27.useRef(null);
  const contentRef = React27.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime139.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId3(),
      titleId: useId3(),
      descriptionId: useId3(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React27.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime139.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime139.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React27.Children.map(children, (child) => (0, import_jsx_runtime139.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime139.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React27.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime139.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime139.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime139.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime139.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent = React27.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return (0, import_jsx_runtime139.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime139.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime139.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME;
var DialogContentModal = React27.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = React27.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React27.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime139.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React27.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = React27.useRef(false);
    const hasPointerDownOutsideRef = React27.useRef(false);
    return (0, import_jsx_runtime139.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = React27.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime139.jsxs)(import_jsx_runtime139.Fragment, { children: [
      (0, import_jsx_runtime139.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime139.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime139.jsxs)(import_jsx_runtime139.Fragment, { children: [
        (0, import_jsx_runtime139.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime139.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime139.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime139.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime139.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React27.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React27.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog;
var Trigger = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Title2 = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// node_modules/@xelene/vaul-with-scroll-fix/dist/index.mjs
var React28 = __toESM(require_react(), 1);
var import_react60 = __toESM(require_react(), 1);
function __insertCSS(code) {
  if (!code || typeof document == "undefined") return;
  let head = document.head || document.getElementsByTagName("head")[0];
  let style = document.createElement("style");
  style.type = "text/css";
  head.appendChild(style);
  style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));
}
var DrawerContext = import_react60.default.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  scaleBackground: () => {
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: false,
  isOpen: false,
  keyboardIsOpen: {
    current: false
  },
  snapPointsOffset: null,
  snapPoints: null,
  modal: false,
  shouldFade: false,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  visible: false,
  closeDrawer: () => {
  },
  setVisible: () => {
  },
  direction: "bottom"
});
var useDrawerContext = () => import_react60.default.useContext(DrawerContext);
__insertCSS("[vaul-drawer]{touch-action:none;transition:transform .5s cubic-bezier(.32, .72, 0, 1)}[vaul-drawer][vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[vaul-drawer][vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[vaul-drawer][vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[vaul-drawer][vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}.vaul-dragging .vaul-scrollable [vault-drawer-direction=top]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=bottom]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=left]{overflow-x:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=right]{overflow-x:hidden!important}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]::after{content:'';position:absolute;background:inherit;background-color:inherit}[vaul-drawer][vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[vaul-drawer][vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible=false]){opacity:1}");
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react60.useLayoutEffect : import_react60.useEffect;
function chain(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function isMac() {
  return testPlatform(/^Mac/);
}
function isIPhone() {
  return testPlatform(/^iPhone/);
}
function isIPad() {
  return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function testPlatform(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(window.navigator.platform) : void 0;
}
var visualViewport = typeof document !== "undefined" && window.visualViewport;
function isScrollable(node) {
  let style = window.getComputedStyle(node);
  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}
function getScrollParent(node) {
  if (isScrollable(node)) {
    node = node.parentElement;
  }
  while (node && !isScrollable(node)) {
    node = node.parentElement;
  }
  return node || document.scrollingElement || document.documentElement;
}
var nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var preventScrollCount = 0;
var restore;
function usePreventScroll(options = {}) {
  let { isDisabled } = options;
  useIsomorphicLayoutEffect2(() => {
    if (isDisabled) {
      return;
    }
    preventScrollCount++;
    if (preventScrollCount === 1) {
      if (isIOS()) {
        restore = preventScrollMobileSafari();
      } else {
        restore = preventScrollStandard();
      }
    }
    return () => {
      preventScrollCount--;
      if (preventScrollCount === 0) {
        restore();
      }
    };
  }, [
    isDisabled
  ]);
}
function preventScrollStandard() {
  return chain(setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
}
function preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  let onTouchStart = (e) => {
    scrollable = getScrollParent(e.target);
    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }
    lastY = e.changedTouches[0].pageY;
  };
  let onTouchMove = (e) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    }
    let y = e.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (bottom === 0) {
      return;
    }
    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }
    lastY = y;
  };
  let onTouchEnd = (e) => {
    let target = e.target;
    if (isInput(target) && target !== document.activeElement) {
      e.preventDefault();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
  };
  let onFocus = (e) => {
    let target = e.target;
    if (isInput(target)) {
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if (visualViewport) {
          if (visualViewport.height < window.innerHeight) {
            requestAnimationFrame(() => {
              scrollIntoView(target);
            });
          } else {
            visualViewport.addEventListener("resize", () => scrollIntoView(target), {
              once: true
            });
          }
        }
      });
    }
  };
  let restoreStyles = chain(setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  let removeEvents = chain(addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), addEvent(document, "focus", onFocus, true));
  return () => {
    restoreStyles();
    removeEvents();
  };
}
function setStyle(element, style, value) {
  let cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
}
function addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function scrollIntoView(target) {
  let root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    let scrollable = getScrollParent(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      let targetBottom = target.getBoundingClientRect().bottom;
      const keyboardHeight = scrollable.getBoundingClientRect().bottom;
      if (targetBottom > keyboardHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    target = scrollable.parentElement;
  }
}
function isInput(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
function setRef3(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs2(...refs) {
  return (node) => refs.forEach((ref) => setRef3(ref, node));
}
function useComposedRefs2(...refs) {
  return React28.useCallback(composeRefs2(...refs), refs);
}
var previousBodyPosition = null;
function usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration }) {
  const [activeUrl, setActiveUrl] = import_react60.default.useState(typeof window !== "undefined" ? window.location.href : "");
  const scrollPos = import_react60.default.useRef(0);
  const setPositionFixed = import_react60.default.useCallback(() => {
    if (previousBodyPosition === null && isOpen) {
      previousBodyPosition = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX, innerHeight } = window;
      document.body.style.setProperty("position", "fixed", "important");
      document.body.style.top = `${-scrollPos.current}px`;
      document.body.style.left = `${-scrollX}px`;
      document.body.style.right = "0px";
      document.body.style.height = "auto";
      setTimeout(() => requestAnimationFrame(() => {
        console.log([
          "scrollPosition",
          scrollPos.current,
          innerHeight
        ]);
        if (scrollPos.current >= innerHeight) {
          document.body.style.top = `${-scrollPos.current}px`;
        }
      }), 300);
    }
  }, [
    isOpen
  ]);
  const restorePositionSetting = import_react60.default.useCallback(() => {
    if (previousBodyPosition !== null) {
      const y = -parseInt(document.body.style.top, 10);
      const x = -parseInt(document.body.style.left, 10);
      document.body.style.position = previousBodyPosition.position;
      document.body.style.top = previousBodyPosition.top;
      document.body.style.left = previousBodyPosition.left;
      document.body.style.height = previousBodyPosition.height;
      document.body.style.right = "unset";
      requestAnimationFrame(() => {
        if (preventScrollRestoration && activeUrl !== window.location.href) {
          setActiveUrl(window.location.href);
          return;
        }
        window.scrollTo(x, y);
      });
      previousBodyPosition = null;
    }
  }, [
    activeUrl
  ]);
  import_react60.default.useEffect(() => {
    function onScroll() {
      scrollPos.current = window.scrollY;
    }
    onScroll();
    window.addEventListener("scroll", onScroll);
    return () => {
      window.removeEventListener("scroll", onScroll);
    };
  }, []);
  import_react60.default.useEffect(() => {
    if (nested || !hasBeenOpened) return;
    if (isOpen) {
      if (!modal) {
        setTimeout(() => {
          restorePositionSetting();
        }, 500);
      }
    } else {
      restorePositionSetting();
    }
  }, [
    isOpen,
    hasBeenOpened,
    activeUrl,
    modal,
    nested,
    setPositionFixed,
    restorePositionSetting
  ]);
  return {
    restorePositionSetting
  };
}
var cache = /* @__PURE__ */ new WeakMap();
function set(el, styles, ignoreCache = false) {
  if (!el || !(el instanceof HTMLElement) || !styles) return;
  let originalStyles = {};
  Object.entries(styles).forEach(([key, value]) => {
    if (key.startsWith("--")) {
      el.style.setProperty(key, value);
      return;
    }
    originalStyles[key] = el.style[key];
    el.style[key] = value;
  });
  if (ignoreCache) return;
  cache.set(el, originalStyles);
}
function reset(el, prop) {
  if (!el || !(el instanceof HTMLElement)) return;
  let originalStyles = cache.get(el);
  if (!originalStyles) {
    return;
  }
  if (prop) {
    el.style[prop] = originalStyles[prop];
  } else {
    Object.entries(originalStyles).forEach(([key, value]) => {
      el.style[key] = value;
    });
  }
}
var isVertical = (direction) => {
  switch (direction) {
    case "top":
    case "bottom":
      return true;
    case "left":
    case "right":
      return false;
    default:
      return direction;
  }
};
function getTranslate(element, direction) {
  if (!element) {
    return null;
  }
  const style = window.getComputedStyle(element);
  const transform = (
    // @ts-ignore
    style.transform || style.webkitTransform || style.mozTransform
  );
  let mat = transform.match(/^matrix3d\((.+)\)$/);
  if (mat) {
    return parseFloat(mat[1].split(", ")[isVertical(direction) ? 13 : 12]);
  }
  mat = transform.match(/^matrix\((.+)\)$/);
  return mat ? parseFloat(mat[1].split(", ")[isVertical(direction) ? 5 : 4]) : null;
}
function dampenValue(v) {
  return 8 * (Math.log(v + 1) - 2);
}
var TRANSITIONS = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
};
var VELOCITY_THRESHOLD = 0.4;
function useCallbackRef3(callback) {
  const callbackRef = import_react60.default.useRef(callback);
  import_react60.default.useEffect(() => {
    callbackRef.current = callback;
  });
  return import_react60.default.useMemo(() => (...args) => callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);
}
function useUncontrolledState2({ defaultProp, onChange }) {
  const uncontrolledState = import_react60.default.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = import_react60.default.useRef(value);
  const handleChange = useCallbackRef3(onChange);
  import_react60.default.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
function useControllableState2({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState2({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef3(onChange);
  const setValue = import_react60.default.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value2 !== prop) handleChange(value2);
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value,
    setValue
  ];
}
function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = "bottom" }) {
  const [activeSnapPoint, setActiveSnapPoint] = useControllableState2({
    prop: activeSnapPointProp,
    defaultProp: snapPoints == null ? void 0 : snapPoints[0],
    onChange: setActiveSnapPointProp
  });
  const isLastSnapPoint = import_react60.default.useMemo(() => activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [
    snapPoints,
    activeSnapPoint
  ]);
  const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;
  const activeSnapPointIndex = import_react60.default.useMemo(() => snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPoint), [
    snapPoints,
    activeSnapPoint
  ]);
  const snapPointsOffset = import_react60.default.useMemo(() => {
    var _snapPoints_map;
    return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint) => {
      const hasWindow = typeof window !== "undefined";
      const isPx = typeof snapPoint === "string";
      let snapPointAsNumber = 0;
      if (isPx) {
        snapPointAsNumber = parseInt(snapPoint, 10);
      }
      if (isVertical(direction)) {
        const height = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerHeight : 0;
        if (hasWindow) {
          return direction === "bottom" ? window.innerHeight - height : -window.innerHeight + height;
        }
        return height;
      }
      const width = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerWidth : 0;
      if (hasWindow) {
        return direction === "right" ? window.innerWidth - width : -window.innerWidth + width;
      }
      return width;
    })) != null ? _snapPoints_map : [];
  }, [
    snapPoints
  ]);
  const activeSnapPointOffset = import_react60.default.useMemo(() => activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [
    snapPointsOffset,
    activeSnapPointIndex
  ]);
  const snapToPoint = import_react60.default.useCallback((dimension) => {
    var _snapPointsOffset_findIndex;
    const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim) => snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;
    onSnapPointChange(newSnapPointIndex);
    set(drawerRef.current, {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`
    });
    if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex) {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "0"
      });
    } else {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "1"
      });
    }
    setActiveSnapPoint(newSnapPointIndex !== null ? snapPoints == null ? void 0 : snapPoints[newSnapPointIndex] : null);
  }, [
    drawerRef.current,
    snapPoints,
    snapPointsOffset,
    fadeFromIndex,
    overlayRef,
    setActiveSnapPoint
  ]);
  import_react60.default.useEffect(() => {
    if (activeSnapPointProp) {
      var _snapPoints_findIndex;
      const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPointProp)) != null ? _snapPoints_findIndex : -1;
      if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === "number") {
        snapToPoint(snapPointsOffset[newIndex]);
      }
    }
  }, [
    activeSnapPointProp,
    snapPoints,
    snapPointsOffset,
    snapToPoint
  ]);
  function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {
    if (fadeFromIndex === void 0) return;
    const currentPosition = direction === "bottom" || direction === "right" ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;
    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;
    const isFirst = activeSnapPointIndex === 0;
    const hasDraggedUp = draggedDistance > 0;
    if (isOverlaySnapPoint) {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
    if (velocity > 2 && !hasDraggedUp) {
      if (dismissible) closeDrawer();
      else snapToPoint(snapPointsOffset[0]);
      return;
    }
    if (velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {
      snapToPoint(snapPointsOffset[snapPoints.length - 1]);
      return;
    }
    const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr) => {
      if (typeof prev !== "number" || typeof curr !== "number") return prev;
      return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;
    });
    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;
    if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {
      const dragDirection = hasDraggedUp ? 1 : -1;
      if (dragDirection > 0 && isLastSnapPoint) {
        snapToPoint(snapPointsOffset[snapPoints.length - 1]);
        return;
      }
      if (isFirst && dragDirection < 0 && dismissible) {
        closeDrawer();
      }
      if (activeSnapPointIndex === null) return;
      snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);
      return;
    }
    snapToPoint(closestSnapPoint);
  }
  function onDrag({ draggedDistance }) {
    if (activeSnapPointOffset === null) return;
    const newValue = direction === "bottom" || direction === "right" ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;
    if ((direction === "bottom" || direction === "right") && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {
      return;
    }
    if ((direction === "top" || direction === "left") && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {
      return;
    }
    set(drawerRef.current, {
      transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`
    });
  }
  function getPercentageDragged(absDraggedDistance, isDraggingDown) {
    if (!snapPoints || typeof activeSnapPointIndex !== "number" || !snapPointsOffset || fadeFromIndex === void 0) return null;
    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;
    const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;
    if (isOverlaySnapPointOrHigher && isDraggingDown) {
      return 0;
    }
    if (isOverlaySnapPoint && !isDraggingDown) return 1;
    if (!shouldFade && !isOverlaySnapPoint) return null;
    const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;
    const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];
    const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);
    if (isOverlaySnapPoint) {
      return 1 - percentageDragged;
    } else {
      return percentageDragged;
    }
  }
  return {
    isLastSnapPoint,
    activeSnapPoint,
    shouldFade,
    getPercentageDragged,
    setActiveSnapPoint,
    activeSnapPointIndex,
    onRelease,
    onDrag,
    snapPointsOffset
  };
}
var CLOSE_THRESHOLD = 0.25;
var SCROLL_LOCK_TIMEOUT = 100;
var BORDER_RADIUS = 8;
var NESTED_DISPLACEMENT = 16;
var WINDOW_TOP_OFFSET = 26;
var DRAG_CLASS = "vaul-dragging";
function Root2({ open: openProp, onOpenChange, children, shouldScaleBackground, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, nested = false, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, direction = "bottom", preventScrollRestoration = true, disablePreventScroll = false }) {
  var _drawerRef_current;
  const [isOpen = false, setIsOpen] = import_react60.default.useState(false);
  const [hasBeenOpened, setHasBeenOpened] = import_react60.default.useState(false);
  const [visible, setVisible] = import_react60.default.useState(false);
  const [mounted, setMounted] = import_react60.default.useState(false);
  const [isDragging, setIsDragging] = import_react60.default.useState(false);
  const [justReleased, setJustReleased] = import_react60.default.useState(false);
  const overlayRef = import_react60.default.useRef(null);
  const openTime = import_react60.default.useRef(null);
  const dragStartTime = import_react60.default.useRef(null);
  const dragEndTime = import_react60.default.useRef(null);
  const lastTimeDragPrevented = import_react60.default.useRef(null);
  const isAllowedToDrag = import_react60.default.useRef(false);
  const nestedOpenChangeTimer = import_react60.default.useRef(null);
  const pointerStart = import_react60.default.useRef(0);
  const keyboardIsOpen = import_react60.default.useRef(false);
  const previousDiffFromInitial = import_react60.default.useRef(0);
  const drawerRef = import_react60.default.useRef(null);
  const drawerHeightRef = import_react60.default.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);
  const initialDrawerHeight = import_react60.default.useRef(0);
  const onSnapPointChange = import_react60.default.useCallback((activeSnapPointIndex2) => {
    if (snapPoints && activeSnapPointIndex2 === snapPointsOffset.length - 1) openTime.current = /* @__PURE__ */ new Date();
  }, []);
  const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({
    snapPoints,
    activeSnapPointProp,
    setActiveSnapPointProp,
    drawerRef,
    fadeFromIndex,
    overlayRef,
    onSnapPointChange,
    direction
  });
  usePreventScroll({
    isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || disablePreventScroll
  });
  const { restorePositionSetting } = usePositionFixed({
    isOpen,
    modal,
    nested,
    hasBeenOpened,
    preventScrollRestoration
  });
  function getScale2() {
    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
  }
  function onPress(event) {
    var _drawerRef_current2;
    if (!dismissible && !snapPoints) return;
    if (drawerRef.current && !drawerRef.current.contains(event.target)) return;
    drawerHeightRef.current = ((_drawerRef_current2 = drawerRef.current) == null ? void 0 : _drawerRef_current2.getBoundingClientRect().height) || 0;
    setIsDragging(true);
    dragStartTime.current = /* @__PURE__ */ new Date();
    if (isIOS()) {
      window.addEventListener("touchend", () => isAllowedToDrag.current = false, {
        once: true
      });
    }
    event.target.setPointerCapture(event.pointerId);
    pointerStart.current = isVertical(direction) ? event.clientY : event.clientX;
  }
  function shouldDrag(el, isDraggingInDirection) {
    var _window_getSelection;
    let element = el;
    const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();
    const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;
    const date = /* @__PURE__ */ new Date();
    if (element.hasAttribute("data-vaul-no-drag") || element.closest("[data-vaul-no-drag]")) {
      return false;
    }
    if (direction === "right" || direction === "left") {
      return true;
    }
    if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {
      return false;
    }
    if (swipeAmount !== null) {
      if (direction === "bottom" ? swipeAmount > 0 : swipeAmount < 0) {
        return true;
      }
    }
    if (highlightedText && highlightedText.length > 0) {
      return false;
    }
    if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {
      lastTimeDragPrevented.current = date;
      return false;
    }
    if (isDraggingInDirection) {
      lastTimeDragPrevented.current = date;
      return false;
    }
    while (element) {
      if (element.scrollHeight > element.clientHeight) {
        if (element.scrollTop !== 0) {
          lastTimeDragPrevented.current = /* @__PURE__ */ new Date();
          return false;
        }
        if (element.getAttribute("role") === "dialog") {
          return true;
        }
      }
      element = element.parentNode;
    }
    return true;
  }
  function onDrag(event) {
    if (!drawerRef.current) {
      return;
    }
    if (isDragging) {
      const directionMultiplier = direction === "bottom" || direction === "right" ? 1 : -1;
      const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX)) * directionMultiplier;
      const isDraggingInDirection = draggedDistance > 0;
      const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;
      if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;
      const absDraggedDistance = Math.abs(draggedDistance);
      const wrapper = document.querySelector("[vaul-drawer-wrapper]");
      let percentageDragged = absDraggedDistance / drawerHeightRef.current;
      const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);
      if (snapPointPercentageDragged !== null) {
        percentageDragged = snapPointPercentageDragged;
      }
      if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {
        return;
      }
      if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;
      drawerRef.current.classList.add(DRAG_CLASS);
      isAllowedToDrag.current = true;
      set(drawerRef.current, {
        transition: "none"
      });
      set(overlayRef.current, {
        transition: "none"
      });
      if (snapPoints) {
        onDragSnapPoints({
          draggedDistance
        });
      }
      if (isDraggingInDirection && !snapPoints) {
        const dampenedDraggedDistance = dampenValue(draggedDistance);
        const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;
        set(drawerRef.current, {
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
        return;
      }
      const opacityValue = 1 - percentageDragged;
      if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {
        onDragProp == null ? void 0 : onDragProp(event, percentageDragged);
        set(overlayRef.current, {
          opacity: `${opacityValue}`,
          transition: "none"
        }, true);
      }
      if (wrapper && overlayRef.current && shouldScaleBackground) {
        const scaleValue = Math.min(getScale2() + percentageDragged * (1 - getScale2()), 1);
        const borderRadiusValue = 8 - percentageDragged * 8;
        const translateValue = Math.max(0, 14 - percentageDragged * 14);
        set(wrapper, {
          borderRadius: `${borderRadiusValue}px`,
          transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,
          transition: "none"
        }, true);
      }
      if (!snapPoints) {
        const translateValue = absDraggedDistance * directionMultiplier;
        set(drawerRef.current, {
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
      }
    }
  }
  import_react60.default.useEffect(() => {
    return () => {
      scaleBackground(false);
      restorePositionSetting();
    };
  }, []);
  import_react60.default.useEffect(() => {
    var _window_visualViewport;
    function onVisualViewportChange() {
      if (!drawerRef.current) return;
      const focusedElement = document.activeElement;
      if (isInput(focusedElement) || keyboardIsOpen.current) {
        var _window_visualViewport2;
        const visualViewportHeight = ((_window_visualViewport2 = window.visualViewport) == null ? void 0 : _window_visualViewport2.height) || 0;
        let diffFromInitial = window.innerHeight - visualViewportHeight;
        const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;
        if (!initialDrawerHeight.current) {
          initialDrawerHeight.current = drawerHeight;
        }
        const offsetFromTop = drawerRef.current.getBoundingClientRect().top;
        if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {
          keyboardIsOpen.current = !keyboardIsOpen.current;
        }
        if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {
          const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;
          diffFromInitial += activeSnapPointHeight;
        }
        previousDiffFromInitial.current = diffFromInitial;
        if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {
          const height = drawerRef.current.getBoundingClientRect().height;
          let newDrawerHeight = height;
          if (height > visualViewportHeight) {
            newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;
          }
          if (fixed) {
            drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;
          } else {
            drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
          }
        } else {
          drawerRef.current.style.height = `${initialDrawerHeight.current}px`;
        }
        if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {
          drawerRef.current.style.bottom = `0px`;
        } else {
          drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;
        }
      }
    }
    (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener("resize", onVisualViewportChange);
    return () => {
      var _window_visualViewport2;
      return (_window_visualViewport2 = window.visualViewport) == null ? void 0 : _window_visualViewport2.removeEventListener("resize", onVisualViewportChange);
    };
  }, [
    activeSnapPointIndex,
    snapPoints,
    snapPointsOffset
  ]);
  function closeDrawer() {
    if (!drawerRef.current) return;
    cancelDrag();
    onClose == null ? void 0 : onClose();
    set(drawerRef.current, {
      transform: isVertical(direction) ? `translate3d(0, ${direction === "bottom" ? "100%" : "-100%"}, 0)` : `translate3d(${direction === "right" ? "100%" : "-100%"}, 0, 0)`,
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set(overlayRef.current, {
      opacity: "0",
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    scaleBackground(false);
    setTimeout(() => {
      setVisible(false);
      setIsOpen(false);
    }, 300);
    setTimeout(() => {
      if (snapPoints) {
        setActiveSnapPoint(snapPoints[0]);
      }
    }, TRANSITIONS.DURATION * 1e3);
  }
  import_react60.default.useEffect(() => {
    if (!isOpen && shouldScaleBackground) {
      const id = setTimeout(() => {
        reset(document.body);
      }, 200);
      return () => clearTimeout(id);
    }
  }, [
    isOpen,
    shouldScaleBackground
  ]);
  import_react60.default.useLayoutEffect(() => {
    if (openProp) {
      setIsOpen(true);
      setHasBeenOpened(true);
    } else {
      closeDrawer();
    }
  }, [
    openProp
  ]);
  import_react60.default.useEffect(() => {
    if (mounted) {
      onOpenChange == null ? void 0 : onOpenChange(isOpen);
    }
  }, [
    isOpen
  ]);
  import_react60.default.useEffect(() => {
    setMounted(true);
  }, []);
  function resetDrawer() {
    if (!drawerRef.current) return;
    const wrapper = document.querySelector("[vaul-drawer-wrapper]");
    const currentSwipeAmount = getTranslate(drawerRef.current, direction);
    set(drawerRef.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set(overlayRef.current, {
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      opacity: "1"
    });
    if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {
      set(wrapper, {
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden",
        ...isVertical(direction) ? {
          transform: `scale(${getScale2()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${getScale2()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      }, true);
    }
  }
  function cancelDrag() {
    if (!isDragging || !drawerRef.current) return;
    drawerRef.current.classList.remove(DRAG_CLASS);
    isAllowedToDrag.current = false;
    setIsDragging(false);
    dragEndTime.current = /* @__PURE__ */ new Date();
  }
  function onRelease(event) {
    if (!isDragging || !drawerRef.current) return;
    drawerRef.current.classList.remove(DRAG_CLASS);
    isAllowedToDrag.current = false;
    setIsDragging(false);
    dragEndTime.current = /* @__PURE__ */ new Date();
    const swipeAmount = getTranslate(drawerRef.current, direction);
    if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;
    if (dragStartTime.current === null) return;
    const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();
    const distMoved = pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX);
    const velocity = Math.abs(distMoved) / timeTaken;
    if (velocity > 0.05) {
      setJustReleased(true);
      setTimeout(() => {
        setJustReleased(false);
      }, 200);
    }
    if (snapPoints) {
      const directionMultiplier = direction === "bottom" || direction === "right" ? 1 : -1;
      onReleaseSnapPoints({
        draggedDistance: distMoved * directionMultiplier,
        closeDrawer,
        velocity,
        dismissible
      });
      onReleaseProp == null ? void 0 : onReleaseProp(event, true);
      return;
    }
    if (direction === "bottom" || direction === "right" ? distMoved > 0 : distMoved < 0) {
      resetDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, true);
      return;
    }
    if (velocity > VELOCITY_THRESHOLD) {
      closeDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, false);
      return;
    }
    var _drawerRef_current_getBoundingClientRect_height;
    const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);
    if (swipeAmount >= visibleDrawerHeight * closeThreshold) {
      closeDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, false);
      return;
    }
    onReleaseProp == null ? void 0 : onReleaseProp(event, true);
    resetDrawer();
  }
  import_react60.default.useEffect(() => {
    if (isOpen) {
      set(document.documentElement, {
        scrollBehavior: "auto"
      });
      openTime.current = /* @__PURE__ */ new Date();
      scaleBackground(true);
    }
  }, [
    isOpen
  ]);
  import_react60.default.useEffect(() => {
    if (drawerRef.current && visible) {
      var _drawerRef_current2;
      const children2 = drawerRef == null ? void 0 : (_drawerRef_current2 = drawerRef.current) == null ? void 0 : _drawerRef_current2.querySelectorAll("*");
      children2 == null ? void 0 : children2.forEach((child) => {
        const htmlChild = child;
        if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {
          htmlChild.classList.add("vaul-scrollable");
        }
      });
    }
  }, [
    visible
  ]);
  function scaleBackground(open) {
    const wrapper = document.querySelector("[vaul-drawer-wrapper]");
    if (!wrapper || !shouldScaleBackground) return;
    if (open) {
      set(document.body, {
        background: document.body.style.backgroundColor || document.body.style.background
      });
      set(document.body, {
        background: "black"
      }, true);
      set(wrapper, {
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden",
        ...isVertical(direction) ? {
          transform: `scale(${getScale2()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${getScale2()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    } else {
      reset(wrapper, "overflow");
      reset(wrapper, "transform");
      reset(wrapper, "borderRadius");
      set(wrapper, {
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
  }
  function onNestedOpenChange(o) {
    const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;
    const y = o ? -NESTED_DISPLACEMENT : 0;
    if (nestedOpenChangeTimer.current) {
      window.clearTimeout(nestedOpenChangeTimer.current);
    }
    set(drawerRef.current, {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: `scale(${scale}) translate3d(0, ${y}px, 0)`
    });
    if (!o && drawerRef.current) {
      nestedOpenChangeTimer.current = setTimeout(() => {
        const translateValue = getTranslate(drawerRef.current, direction);
        set(drawerRef.current, {
          transition: "none",
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
      }, 500);
    }
  }
  function onNestedDrag(event, percentageDragged) {
    if (percentageDragged < 0) return;
    const initialDim = isVertical(direction) ? window.innerHeight : window.innerWidth;
    const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;
    const newScale = initialScale + percentageDragged * (1 - initialScale);
    const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;
    set(drawerRef.current, {
      transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,
      transition: "none"
    });
  }
  function onNestedRelease(event, o) {
    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;
    const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;
    const translate = o ? -NESTED_DISPLACEMENT : 0;
    if (o) {
      set(drawerRef.current, {
        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`
      });
    }
  }
  return import_react60.default.createElement(Root, {
    modal,
    onOpenChange: (o) => {
      if (openProp !== void 0) {
        onOpenChange == null ? void 0 : onOpenChange(o);
        return;
      }
      if (!o) {
        closeDrawer();
      } else {
        setHasBeenOpened(true);
        setIsOpen(o);
      }
    },
    open: isOpen
  }, import_react60.default.createElement(DrawerContext.Provider, {
    value: {
      visible,
      activeSnapPoint,
      snapPoints,
      setActiveSnapPoint,
      drawerRef,
      overlayRef,
      scaleBackground,
      onOpenChange,
      onPress,
      setVisible,
      onRelease,
      onDrag,
      dismissible,
      isOpen,
      shouldFade,
      closeDrawer,
      onNestedDrag,
      onNestedOpenChange,
      onNestedRelease,
      keyboardIsOpen,
      openProp,
      modal,
      snapPointsOffset,
      direction
    }
  }, children));
}
var Overlay2 = import_react60.default.forwardRef(function({ children, ...rest }, ref) {
  const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, visible } = useDrawerContext();
  const composedRef = useComposedRefs2(ref, overlayRef);
  const hasSnapPoints = snapPoints && snapPoints.length > 0;
  return import_react60.default.createElement(Overlay, {
    onMouseUp: onRelease,
    ref: composedRef,
    "vaul-drawer-visible": visible ? "true" : "false",
    "vaul-overlay": "",
    "vaul-snap-points": isOpen && hasSnapPoints ? "true" : "false",
    "vaul-snap-points-overlay": isOpen && shouldFade ? "true" : "false",
    ...rest
  });
});
Overlay2.displayName = "Drawer.Overlay";
var Content2 = import_react60.default.forwardRef(function({ onOpenAutoFocus, onPointerDownOutside, onAnimationEnd, style, ...rest }, ref) {
  const { drawerRef, onPress, onRelease, onDrag, dismissible, keyboardIsOpen, snapPointsOffset, visible, closeDrawer, modal, openProp, onOpenChange, setVisible, direction } = useDrawerContext();
  const composedRef = useComposedRefs2(ref, drawerRef);
  const pointerStartRef = import_react60.default.useRef(null);
  import_react60.default.useEffect(() => {
    setVisible(true);
  }, []);
  const isDeltaInDirection = (delta, direction2, threshold = 0) => {
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction2 === "left" || direction2 === "right") {
      return isDeltaX && deltaX > threshold;
    } else {
      return !isDeltaX && deltaY > threshold;
    }
  };
  return import_react60.default.createElement(Content, {
    "vaul-drawer": "",
    "vaul-drawer-direction": direction,
    "vaul-drawer-visible": visible ? "true" : "false",
    ...rest,
    ref: composedRef,
    style: snapPointsOffset && snapPointsOffset.length > 0 ? {
      "--snap-point-height": `${snapPointsOffset[0]}px`,
      ...style
    } : style,
    onOpenAutoFocus: (e) => {
      if (onOpenAutoFocus) {
        onOpenAutoFocus(e);
      } else {
        var _drawerRef_current;
        e.preventDefault();
        (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.focus();
      }
    },
    onPointerDown: (event) => {
      rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);
      pointerStartRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      onPress(event);
    },
    onPointerDownOutside: (e) => {
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);
      if (!modal || e.defaultPrevented) {
        e.preventDefault();
        return;
      }
      if (keyboardIsOpen.current) {
        keyboardIsOpen.current = false;
      }
      e.preventDefault();
      onOpenChange == null ? void 0 : onOpenChange(false);
      if (!dismissible || openProp !== void 0) {
        return;
      }
      closeDrawer();
    },
    onPointerMove: (event) => {
      rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);
      if (!pointerStartRef.current) return null;
      const yPosition = event.clientY - pointerStartRef.current.y;
      const xPosition = event.clientX - pointerStartRef.current.x;
      const isHorizontalSwipe = [
        "left",
        "right"
      ].includes(direction);
      const clamp3 = [
        "left",
        "top"
      ].includes(direction) ? Math.min : Math.max;
      const clampedX = isHorizontalSwipe ? clamp3(0, xPosition) : 0;
      const clampedY = !isHorizontalSwipe ? clamp3(0, yPosition) : 0;
      const swipeStartThreshold = event.pointerType === "touch" ? 10 : 2;
      const delta = {
        x: clampedX,
        y: clampedY
      };
      const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);
      if (isAllowedToSwipe) onDrag(event);
      else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {
        pointerStartRef.current = null;
      }
    },
    onPointerUp: (event) => {
      rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);
      pointerStartRef.current = null;
      onRelease(event);
    }
  });
});
Content2.displayName = "Drawer.Content";
function NestedRoot({ onDrag, onOpenChange, ...rest }) {
  const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();
  if (!onNestedDrag) {
    throw new Error("Drawer.NestedRoot must be placed in another drawer");
  }
  return import_react60.default.createElement(Root2, {
    nested: true,
    onClose: () => {
      onNestedOpenChange(false);
    },
    onDrag: (e, p) => {
      onNestedDrag(e, p);
      onDrag == null ? void 0 : onDrag(e, p);
    },
    onOpenChange: (o) => {
      if (o) {
        onNestedOpenChange(o);
      }
      onOpenChange == null ? void 0 : onOpenChange(o);
    },
    onRelease: onNestedRelease,
    ...rest
  });
}
var Drawer = {
  Root: Root2,
  NestedRoot,
  Content: Content2,
  Overlay: Overlay2,
  Trigger,
  Portal: Portal2,
  Close,
  Title: Title2,
  Description
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/components/ModalClose/ModalClose.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime());
var ModalClose = (props) => (0, import_jsx_runtime140.jsx)(Drawer.Close, _object_spread({
  asChild: true
}, props));

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/components/ModalHeader/ModalHeader.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime());
var import_react61 = __toESM(require_react());
var ModalHeader = (0, import_react61.forwardRef)((_param, ref) => {
  var { before, after, className, children } = _param, props = _object_without_properties(_param, [
    "before",
    "after",
    "className",
    "children"
  ]);
  const platform2 = usePlatform();
  return (0, import_jsx_runtime141.jsxs)("header", _object_spread_props(_object_spread({
    ref,
    className: classNames("tgui-f67c8fb3553eee55", className)
  }, props), {
    children: [
      (0, import_jsx_runtime141.jsx)("div", {
        className: "tgui-09b5f6cfd7ba56ab",
        children: before
      }),
      platform2 === "ios" && (0, import_jsx_runtime141.jsx)(Text, {
        weight: "2",
        className: "tgui-7ce1022bfdcb0ae3",
        children
      }),
      (0, import_jsx_runtime141.jsx)("div", {
        className: "tgui-fe1d6742d85038d7",
        children: after
      })
    ]
  }));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/components/ModalOverlay/ModalOverlay.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime());
var import_react62 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/helpers/color.js
var hexToRGB = (hex) => {
  let fullHex = hex;
  if (hex.length === 4) {
    fullHex = hex.replace(/([^#])/g, "$1$1");
  }
  const bigint = parseInt(fullHex.replace("#", ""), 16);
  const channelR = bigint >> 16;
  const channelG = bigint >> 8;
  return [
    channelR & 255,
    channelG & 255,
    bigint & 255
  ];
};

// node_modules/@telegram-apps/telegram-ui/dist/helpers/telegram.js
var getTelegramData = () => {
  var _window_Telegram;
  if (!canUseDOM) {
    return void 0;
  }
  return (_window_Telegram = window.Telegram) === null || _window_Telegram === void 0 ? void 0 : _window_Telegram.WebApp;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/components/ModalOverlay/ModalOverlay.js
var DEFAULT_LIGHT_OVERLAY_RGB = [
  255,
  255,
  255
];
var DEFAULT_DARK_OVERLAY_RGB = [
  33,
  33,
  33
];
var ModalOverlay = (0, import_react62.forwardRef)((_param, ref) => {
  var { className } = _param, props = _object_without_properties(_param, [
    "className"
  ]);
  const context = useAppRootContext();
  const [r, g, b] = (0, import_react62.useMemo)(() => {
    const telegramData = getTelegramData();
    if (telegramData && telegramData.themeParams.bg_color) {
      return hexToRGB(telegramData.themeParams.bg_color);
    }
    return context.appearance === "light" ? DEFAULT_LIGHT_OVERLAY_RGB : DEFAULT_DARK_OVERLAY_RGB;
  }, [
    context.appearance
  ]);
  return (0, import_jsx_runtime142.jsx)(Drawer.Overlay, _object_spread({
    ref,
    // Opacity on overlay is dynamically calculated based on the percentage of opened drawers
    // This is why we use rgba here and not background: token + opacity
    style: {
      background: `rgba(${r}, ${g}, ${b}, .4)`
    },
    className: classNames("tgui-3197096cb603b35a", className)
  }, props));
});

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Modal/Modal.js
var Modal = (0, import_react63.forwardRef)((_param, ref) => {
  var { overlayComponent = (0, import_jsx_runtime143.jsx)(ModalOverlay, {}), open, onOpenChange, header, className, children, nested, trigger, closeThreshold, scrollLockTimeout, snapPoints, fadeFromIndex, modal, preventScrollRestoration, dismissible } = _param, restProps = _object_without_properties(_param, [
    "overlayComponent",
    "open",
    "onOpenChange",
    "header",
    "className",
    "children",
    "nested",
    "trigger",
    "closeThreshold",
    "scrollLockTimeout",
    "snapPoints",
    "fadeFromIndex",
    "modal",
    "preventScrollRestoration",
    "dismissible"
  ]);
  var _container_portalContainer;
  const container = useAppRootContext();
  const [portal, setPortal] = (0, import_react63.useState)((_container_portalContainer = container.portalContainer) === null || _container_portalContainer === void 0 ? void 0 : _container_portalContainer.current);
  (0, import_react63.useEffect)(() => {
    var _container_portalContainer2;
    setPortal((_container_portalContainer2 = container.portalContainer) === null || _container_portalContainer2 === void 0 ? void 0 : _container_portalContainer2.current);
  }, [
    container.portalContainer
  ]);
  const Component = nested ? Drawer.NestedRoot : Drawer.Root;
  return (0, import_jsx_runtime143.jsxs)(Component, {
    open,
    onOpenChange,
    closeThreshold,
    scrollLockTimeout,
    snapPoints,
    fadeFromIndex,
    modal,
    preventScrollRestoration,
    dismissible,
    children: [
      trigger && (0, import_jsx_runtime143.jsx)(Drawer.Trigger, {
        asChild: true,
        children: trigger
      }),
      (0, import_jsx_runtime143.jsxs)(Drawer.Portal, {
        container: portal,
        children: [
          overlayComponent,
          (0, import_jsx_runtime143.jsxs)(Drawer.Content, _object_spread_props(_object_spread({
            ref,
            className: classNames("tgui-cc76354712c6e8d9", className)
          }, restProps), {
            children: [
              header,
              (0, import_jsx_runtime143.jsx)("div", {
                className: "tgui-5dc6ad1ca3ac3ed4",
                children
              })
            ]
          }))
        ]
      })
    ]
  });
});
Modal.Header = ModalHeader;
Modal.Overlay = ModalOverlay;
Modal.Close = ModalClose;

// node_modules/@telegram-apps/telegram-ui/dist/components/Overlays/Tooltip/Tooltip.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime());
var Tooltip = (_param) => {
  var { mode = "light", children, className, arrowProps } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "className",
    "arrowProps"
  ]);
  return (0, import_jsx_runtime144.jsx)(Popper, _object_spread_props(_object_spread({
    withArrow: true,
    arrowProps: _object_spread_props(_object_spread({}, arrowProps), {
      className: classNames("tgui-e0107e1e5ea5b9f3", arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.className)
    }),
    className: classNames("tgui-5638a4ef4e806d8c", mode === "dark" && "tgui-bc60ca772e3ae3c6", className)
  }, restProps), {
    children: (0, import_jsx_runtime144.jsx)(Caption, {
      level: "1",
      children
    })
  }));
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/AppRoot.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime());
var import_react67 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/useAppearance.js
var import_react64 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/helpers/getBrowserAppearanceSubscriber.js
var getBrowserAppearanceSubscriber = (setAppearance) => {
  if (!canUseDOM || !window.matchMedia) {
    return () => {
    };
  }
  const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
  const listener = () => {
    setAppearance(mediaQuery.matches ? "dark" : "light");
  };
  mediaQuery.addEventListener("change", listener);
  return () => mediaQuery.removeEventListener("change", listener);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/helpers/getInitialAppearance.js
var getInitialAppearance = () => {
  if (canUseDOM && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
    return "dark";
  }
  return "light";
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/useAppearance.js
var useAppearance = (appearanceProp) => {
  const { appearance: contextAppearance } = (0, import_react64.useContext)(AppRootContext);
  const [appearance, setAppearance] = (0, import_react64.useState)(appearanceProp || contextAppearance || getInitialAppearance());
  const handleThemeChange = (0, import_react64.useCallback)(() => {
    const telegramData = getTelegramData();
    if (!telegramData) {
      return;
    }
    setAppearance(telegramData.colorScheme);
  }, []);
  (0, import_react64.useEffect)(() => {
    if (appearanceProp !== void 0) {
      setAppearance(appearanceProp);
      return () => {
      };
    }
    const telegramData = getTelegramData();
    if (telegramData) {
      telegramData.onEvent("themeChanged", handleThemeChange);
      return () => telegramData.offEvent("themeChanged", handleThemeChange);
    }
    return getBrowserAppearanceSubscriber(setAppearance);
  }, [
    appearanceProp
  ]);
  return appearance;
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/usePlatform.js
var import_react65 = __toESM(require_react());

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/helpers/getInitialPlatform.js
var getInitialPlatform = () => {
  const telegramData = getTelegramData();
  if (!telegramData) {
    return "base";
  }
  if ([
    "ios",
    "macos"
  ].includes(telegramData.platform)) {
    return "ios";
  }
  return "base";
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/usePlatform.js
var usePlatform2 = (platform2) => {
  if (platform2 !== void 0) {
    return platform2;
  }
  const appContext = (0, import_react65.useContext)(AppRootContext);
  if (appContext.isRendered && appContext.platform !== void 0) {
    return appContext.platform;
  }
  return getInitialPlatform();
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/hooks/usePortalContainer.js
var import_react66 = __toESM(require_react());
var usePortalContainer = (portalContainer) => {
  if (portalContainer !== void 0) {
    return portalContainer;
  }
  const appContext = (0, import_react66.useContext)(AppRootContext);
  if (appContext.isRendered && appContext.portalContainer !== void 0) {
    return appContext.portalContainer;
  }
  return (0, import_react66.useRef)(null);
};

// node_modules/@telegram-apps/telegram-ui/dist/components/Service/AppRoot/AppRoot.js
var AppRoot = (0, import_react67.forwardRef)((_param, ref) => {
  var { platform: platformProp, appearance: appearanceProp, portalContainer: portalContainerProp, children, className } = _param, restProps = _object_without_properties(_param, [
    "platform",
    "appearance",
    "portalContainer",
    "children",
    "className"
  ]);
  const appearance = useAppearance(appearanceProp);
  const portalContainer = usePortalContainer(portalContainerProp);
  const platform2 = usePlatform2(platformProp);
  const contextValue = useObjectMemo({
    platform: platform2,
    appearance,
    portalContainer,
    isRendered: true
  });
  return (0, import_jsx_runtime145.jsx)("div", _object_spread_props(_object_spread({
    ref: multipleRef(ref, portalContainer),
    className: classNames("tgui-6a12827a138e8827", platform2 === "ios" && "tgui-56dbb42c1dbd5e2b", appearance === "dark" && "tgui-865b921add8ee075", className)
  }, restProps), {
    children: (0, import_jsx_runtime145.jsx)(AppRootContext.Provider, {
      value: contextValue,
      children
    })
  }));
});
export {
  Accordion,
  AppRoot,
  Avatar,
  AvatarStack,
  Badge,
  Banner,
  Blockquote,
  Breadcrumbs,
  Button,
  ButtonCell,
  Caption,
  Card,
  Cell,
  Checkbox,
  Chip,
  CircularProgress,
  ColorInput,
  CompactPagination,
  Divider,
  FileInput,
  FixedLayout,
  Headline,
  IconButton,
  IconContainer,
  Image,
  Info,
  InlineButtons,
  Input,
  LargeTitle,
  Link,
  List,
  Modal,
  Multiselect,
  Multiselectable,
  Navigation,
  Pagination,
  PinInput,
  Placeholder,
  Popper,
  Progress,
  Radio,
  Rating,
  RootRenderer,
  Section,
  SegmentedControl,
  Select,
  Selectable,
  Skeleton,
  Slider,
  Snackbar,
  Spinner,
  Spoiler,
  Steps,
  Subheadline,
  Switch,
  Tabbar,
  TabsList,
  Tappable,
  Text,
  Textarea,
  Timeline,
  Title,
  Tooltip,
  Typography,
  VisuallyHidden
};
//# sourceMappingURL=@telegram-apps_telegram-ui.js.map
